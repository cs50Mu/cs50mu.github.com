<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[The Hard Way Is Easier]]></title>
  <link href="http://cs50Mu.github.io/atom.xml" rel="self"/>
  <link href="http://cs50Mu.github.io/"/>
  <updated>2015-07-16T12:30:29+08:00</updated>
  <id>http://cs50Mu.github.io/</id>
  <author>
    <name><![CDATA[linuxfish]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[continue blogging on Mac OSX using octoress]]></title>
    <link href="http://cs50Mu.github.io/blog/2015/07/12/continue-blogging-on-macosx-using-octoress/"/>
    <updated>2015-07-12T16:31:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2015/07/12/continue-blogging-on-macosx-using-octoress</id>
    <content type="html"><![CDATA[<p>换了Mac，终于可以继续用Octopress写blog了，但首先得把原来的blog从git上同步过来，纪录下在此过程中遇到的坑。</p>

<ol>
<li><p>clone source分支。</p>

<pre><code> git clone -b source git@github.com:cs50Mu/cs50mu.github.com.git octopress
</code></pre></li>
<li><p>clone master分支到<code>octopress/_deploy</code>文件夹中</p>

<pre><code> git clone git@github.com:cs50Mu/cs50mu.github.com.git _deploy 
</code></pre></li>
<li>重新安装Octopress环境，这里出现了一堆坑。。。

<ul>
<li>ruby gems官方源被墙，这个当时在Archlinux上安装时已经遇到，解决办法不再重复</li>
<li><p>当执行<code>brew install ruby-build</code>提示找不到GCC。这个是因为mac上的gcc用的是苹果自己的编译器llvm，不是GNU版本的gcc，而octopress使用的特定版本的ruby（1.9.3）需要用GNU版的编译器来编译，按照homebrew的提示安装GCC即可</p>

<pre><code>  $ brew update
  $ brew tap homebrew/dupes
  $ brew install autoconf automake apple-gcc42
</code></pre></li>
<li><p>使用rbenv安装<code>Ruby 1.9.3</code>时，安装的ruby版本不能生效。表现的现象是：当执行<code>ruby --version</code>时仍然给出的时mac系统自带的ruby版本。解决办法就是在<code>.bash_profile</code>中添加</p>

<pre><code>  # Initialize rbenv
  if which rbenv &gt; /dev/null; then eval "$(rbenv init -)"; fi
</code></pre>

<p>然后<strong>注意</strong>在zsh shell中需要在<code>.zshrc</code>中添加<code>source ~/.bash_profile</code>，因为zsh shell是不读<code>.bash_profile</code>文件的（或者是因为我安装了oh-my-zsh），还有要记住添加的这一行一定要在<code>.zshrc</code>文件中路径声明的后边！！否则，加这一句也不会起作用。切记，一开始在这个上面被坑了很久。</p></li>
<li>执行<code>$ rake new_post["something to say"]</code>，zsh会报错：<code>zsh: no matches found: new_post[something to say]</code>，原因是<code>[ ]</code>在zsh中是文件名通配符，解决办法：
在<code>.zshrc</code>中加入<code>alias rake="noglob rake"</code></li>
</ul>
</li>
</ol>


<h3>参考</h3>

<ul>
<li><a href="http://blog.zerosharp.com/installing-ruby-with-homebrew-and-rbenv-on-mac-os-x-mountain-lion/">Installing Ruby With Homebrew and Rbenv on Mac OS X Mountain Lion</a></li>
<li><a href="https://ruby-china.org/wiki/rbenv-guide">rbenv-guide</a></li>
<li><a href="http://octopress.org/docs/setup/">Octopress Setup</a></li>
<li><a href="https://github.com/imathis/octopress/issues/117">not compatible with zsh</a></li>
<li><a href="http://liuyix.org/blog/2013/mac-install-octopress/">Mac上安装octopress</a></li>
<li><a href="http://boboshone.com/blog/2013/06/05/write-octopress-blog-on-multiple-machines/">在多台电脑上写Octopress博客</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[test from new mac]]></title>
    <link href="http://cs50Mu.github.io/blog/2015/07/12/test-from-new-mac/"/>
    <updated>2015-07-12T13:04:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2015/07/12/test-from-new-mac</id>
    <content type="html"><![CDATA[<p><strong>if you see this page, then the migration is ok!</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python的logging模块总结]]></title>
    <link href="http://cs50Mu.github.io/blog/2015/02/02/logging-module-of-python/"/>
    <updated>2015-02-02T10:58:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2015/02/02/logging-module-of-python</id>
    <content type="html"><![CDATA[<p>里面主要有这么几个类：logger handler formatter，其中logger类用于实例化logger对象，handler类负责指定log信息的发送目的地，比如你可能希望log信息发送到终端、文件甚至远程主机上，还支持日志轮转，比如<code>RotatingFileHandler</code>支持按文件轮转，<code>TimedRotatingFileHandler</code>支持按时间轮转，formatter类，顾名思义，负责log信息的格式的设定。</p>

<p>使用logging模块的基本流程为：先通过<code>logging.getlogger('loggername')</code>获取一个logger对象，然后根据需求为这个logger对象添加相应的handler和formatter，这样就算基本配置完了，这样就可以在你的程序里使用<code>logging.debug('debug info')</code>等类似语句来输出log信息了。</p>

<p>在实际开发中一般是通过文件来进行配置的，配置信息全写在一个配置文件中，然后在脚本里读取配置信息，一个简单的示例：</p>

<pre><code>import logging
import logging.config

logging.config.fileConfig('logging.conf')

# create logger
logger = logging.getLogger('simpleLogger')

# use it
logger.debug('debug info')
logger.info('info message')
logger.warn('warning info')
logger.critical(''critical info')
</code></pre>

<p>配置文件如下，需要遵守一定的格式，具体要求见参考链接</p>

<pre><code>[loggers]
keys=root, simpleLogger

[handlers]
keys=consoleHandler

[formatters]
keys=simpleFormatter

[logger_root]
level=DEBUG
handlers=consoleHandler
...
...
[formatter_simpleFormatter]
format=%(asctime)s - %(name)s - %(levelname)s - %(message)s
datefmt=
</code></pre>

<h2>参考</h2>

<ul>
<li><a href="https://docs.python.org/2/howto/logging.html">Logging HOWTO</a></li>
<li><a href="https://docs.python.org/2/library/logging.config.html#logging-config-api">Logging configuration</a>  这里详细讲了配置文件到底该怎么写</li>
<li><a href="http://kenby.iteye.com/blog/1162698">使用python的logging模块</a></li>
<li><a href="http://www.cnblogs.com/captain_jack/archive/2011/01/21/1941453.html">Python模块学习——logging</a></li>
<li><a href="http://blog.csdn.net/ithomer/article/details/16985379">Python 学习入门（14）—— logging</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[trivial problems]]></title>
    <link href="http://cs50Mu.github.io/blog/2015/01/20/trivial-problems/"/>
    <updated>2015-01-20T18:40:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2015/01/20/trivial-problems</id>
    <content type="html"><![CDATA[<p>今天很高兴，因为解决了几个困扰很久的问题。</p>

<h2>OpenVPN</h2>

<p>为便于办公，公司提供了VPN，不过只提供了OpenVPN的连接方案，之前在arch上一直是用pptp连接的，大概看了看wiki上OpenVPN的文档，一大堆。。。头大。</p>

<p>不过，今天仔细一看，原来并不麻烦，只要把管理员提供的证书文件等放到相应文件夹上就搞定了！</p>

<blockquote><p>将这几个文件放到/etc/openvpn目录下   xxx.ovpn ca.crt  xxx.crt  xxx.key  其中xxx.pvpn是配置文件
然后就可以启动了！ sudo openvpn /etc/openvpn/xxx.ovpn   会提示输入密码，输入管理员提供的密码即可</p></blockquote>

<h2>urxvt SSH远程登陆的问题</h2>

<p>之前在Arch上用urxvt一直比较happy，不过公司里开发都是SSH远程登陆到linux主机上进行的，那么问题来了，明明在本地显示很正常的vim，SSH到了公司上的Linux主机上，显示就成了一堆渣。。明明vim的配置文件都是一样的啊。。  后来慢慢发现不是vim的问题，是终端的问题！！因为我换用lilyterm后就显示正常了！！然后，终于在今天让我google到解决方案了～</p>

<blockquote><ol>
<li><p>Run the following command on the external host to make a terminfo directory
under the logged in user&rsquo;s home folder.</p>

<pre><code>mkdir -p ~/.terminfo/r/
</code></pre></li>
<li><p>Copy the appropriate terminal profile from your local machine to the newly
created folder on the remote host.</p>

<pre><code>scp /usr/share/terminfo/r/rxvt-unicode-256color user@helloworld.com:.terminfo/r/
</code></pre></li>
<li><p>Restart the SSH connection. It should work now.</p></li>
</ol>
</blockquote>

<h2>vim中使用tab自动补全</h2>

<p>对于程序员来说，这世界上如果没有自动补全的话，简直不能想象。。之前习惯了使用TAB自动补全，现在在公司的远程Linux上却怎么也搞不出TAB自动补全的效果。。配置文件和插件都装一样的也不行。。。真是见鬼了。。 今天发现应该是之前装了supertab，然后不知道怎么又自己给删了，但是效果还在。。在远程Linux上装了supertab后，嗯，就是这个感觉～～</p>

<p>本事件的教训就是，无论做什么一定要做好记录。。</p>

<h2>参考</h2>

<ul>
<li><a href="http://www.cs.helsinki.fi/u/andrews/misc/full_urxvt_support_on_ssh_terminals.txt" title="">FULL URXVT TERMINAL SUPPORT FOR REMOTE (SSH) CONNECTIONS</a></li>
<li><a href="" title="https://stavrovski.net/blog/installing-and-setting-up-openvpn-in-archlinux">Installing and setting up OpenVPN in ArchLinux</a></li>
<li><a href="" title="https://wiki.archlinux.org/index.php/Airvpn">Configuring OpenVPN to connect as a client to an AirVPN server</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[problems about python and mysql]]></title>
    <link href="http://cs50Mu.github.io/blog/2015/01/19/problems-about-python-and-mysql/"/>
    <updated>2015-01-19T15:47:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2015/01/19/problems-about-python-and-mysql</id>
    <content type="html"><![CDATA[<p>记录一下这几天项目上遇到的问题</p>

<h2>Python 2.7的编码问题</h2>

<p>Python 2.x内部处理编码默认还是ascii，在处理utf8编码的数据时会报UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误。这个问题之前就遇到过。</p>

<pre><code>import sys
print sys.getdefaultencoding()  # 获取系统默认编码
reload(sys)
sys.setdefaultencoding('utf-8')  # 重新设置为utf-8
</code></pre>

<h2>MySQL 乱码解决</h2>

<p>创建数据库  <code>CREATE DATABASE test CHARACTER SET utf8 COLLATE utf8_general_ci;</code>   <br/>
创建表    <code>CREATE TABLE test_table (........) ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></p>

<p>Python连接数据库时 <code>conn = MySQLdb.connect(host="localhost", user="root", passwd="root", db="db",  charset="utf8")</code></p>

<h2>git</h2>

<ul>
<li>基于某个分支新建分支
  git branch muchunyu origin/dev  # 假设dev分支不在本地，存在于远程服务器
  git checkout muchunyu  # 切换到这个分支
或者可以直接：   <br/>
  git checkout -b muchunyu origin/dev</li>
<li>只clone某个分支到本地
  git clone -b <branch> &lt;remote_repo></li>
</ul>


<h2>常用数据库操作</h2>

<pre><code>create database xxx; #创建数据库
use xxx;   # 转到某个数据库
create table xxx (....); # 创建表
show tables;  # 显示数据库中的表
describe xxxx; # 显示表结构
drop xxx  # 可以是表名或者数据库名 表的结构 属性 索引都会被删掉
truncate xxx  # 只用于表且只会清空表中数据，不会删除表结构等
</code></pre>

<h2>参考</h2>

<p><a href="http://www.cnblogs.com/mengdd/p/3447464.html">在GitHub上管理项目</a>
<a href="http://www.cnblogs.com/fantiantian/p/3468454.html">Mysql乱码问题解决历程</a>
<a href="http://www.2cto.com/database/201108/101151.html">Mysql中文乱码问题完美解决方案</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Practical Vim 读书笔记]]></title>
    <link href="http://cs50Mu.github.io/blog/2015/01/12/note-from-practical-vim/"/>
    <updated>2015-01-12T11:31:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2015/01/12/note-from-practical-vim</id>
    <content type="html"><![CDATA[<ul>
<li>The Vim Way

<ol>
<li> <code>.</code>命令可以重复做上一次的改变(repeat last change)。这里关键是要理解这个改变的意思，就我现在的理解，这个改变是不包括光标位置的移动的，只是指对文本内容的改变，比如删除 增加等等。理解这一点很重要。</li>
<li> <code>;</code> 分号，配合f使用，移动到下一个匹配的地方，反方向移动为<code>,</code></li>
<li> <code>*</code> 移动到下一个与当前光标处文本匹配的地方，并高亮显示所有匹配文本</li>
</ol>
</li>
<li>Normal Mode

<ol>
<li> <code>aw</code>  &ldquo;a word&rdquo; <code>daw</code>可删除整个单词，不管光标在哪里</li>
<li> <code>&lt;C - a&gt;</code>和<code>&lt;C - x&gt;</code> commands perform addition and subtraction on numbers.</li>
<li> <code>g~</code> swap case 改变大小写  <br/>
<code>gu</code> make lowercase  <br/>
<code>gU</code> make uppercase</li>
<li> <code>=</code> autoindent  自动缩进</li>
</ol>
</li>
<li>Insert Mode.   Most of Vim&rsquo;s commands are triggered from other modes, but some functionality is within easy reach from Insert mode.

<ol>
<li> <code>&lt;C - h&gt;</code> Delete back one character</li>
<li> <code>&lt;C - w&gt;</code> Delete back one word</li>
<li> <code>&lt;C - u&gt;</code> Delete back to start of line</li>
<li> <code>&lt;C - O&gt;</code>  execute one command, return to Insert mode. 所谓的Insert Normal Mode，在insert模式下进入此模式后可以执行一次normal模式下才能执行的命令后立即返回insert模式，可以配合zz（使光标处在屏幕中间）使用。如在编辑过程中光标处在最上端或者最下端了，此时想要看一看上下文，可以使用<code>&lt;C - O&gt;zz</code>，然后又立即可以继续编辑。</li>
<li> <code>&lt;C - r&gt;{register}</code> Paste from a Register Without Leaving Insert Mode. For example, <code>&lt;C - r&gt;0</code>  不适合大段文本，因为这种情况下文本是一个字符一个字符粘贴过来的。</li>
<li> <code>&lt;C - r&gt;=</code>  expression register. 可以用于在寄存器中evaluate表达式，然后把结果返回到当前光标处。</li>
<li> <code>&lt;C - v&gt;{code}</code> Insert unusual characters by character code. For example, <code>&lt;C -v&gt;065</code>   <br/>
<code>&lt;C - v&gt;{123}</code> Insert character by decimal code  <br/>
<code>&lt;C - v&gt;u{1234}</code> Insert character by hexadecimal code</li>
</ol>
</li>
<li>Visual Mode

<ol>
<li> <code>v</code> &ndash;  character-wise Visual mode  <br/>
<code>V</code> &ndash; line-wise Visual mode  <br/>
<code>&lt;C - v&gt;</code> &ndash; block-wise Visual mode  <br/>
<code>gv</code> &ndash; reselect the last visual selection  <br/>
<code>o</code> &ndash; go to the other end of highlighted text</li>
</ol>
</li>
<li>Command-Line Mode

<ol>
<li> <code>.</code> 代表当前行 <code>%</code> 代表所有行</li>
<li> <code>:/&lt;html&gt;/,/&lt;\/html&gt;/p</code>  Specify a range of lines by patterns</li>
<li> <code>:/&lt;html&gt;/+1,/&lt;\/html&gt;/-1p</code>Modify an Address using an offset</li>
<li> <code>[range]copy {address}</code>  Duplicate lines  也可以用<code>:t</code>  移动行用<code>:m</code></li>
<li> <code>@:</code>  Repeating the last Ex command</li>
<li> <code>:%normal A;</code>  Run Normal Mode Commands across a range  在命令行模式下运行normal模式下的命令</li>
<li> <code>&lt;C - d&gt;</code>  ask Vim to reveal a list of possible completions  自动补全</li>
<li> <code>&lt;C -r&gt;&lt;C - w&gt;</code>  Insert the current word at the command prompt</li>
<li> <code>:%s//&lt;C-r&gt;&lt;C-w&gt;/g</code>  Leaving the search field of the substitute command blank instructs Vim to reuse the most recent search pattern  重用上次的search pattern</li>
<li> words与WORDS的区别:As users, we can think of them in simpler terms: WORDS are bigger than words.  WORDS用W B E gE来操作，且移动的跨度比words大</li>
<li> <code>q:</code> 进入Command-Line Window</li>
<li> <code>:shell</code>   The <code>:!{cmd}</code> syntax is great for firing one-off commands, but what if we want to run several commands in the shell? In that case, we can use this command to start an interactive shell session.  可以用exit退出，回到vim</li>
<li> <code>&lt;C - z&gt;</code>  Putting Vim in the background  用<code>fg</code>返回</li>
<li> <code>:read !{cmd}</code> 把cmd运行结果读入当前buffer     <code>:write !{cmd}</code>  Use the contents of the buffer as standard input for the specified {cmd}.</li>
<li> Filtering the contents of a buffer through an external command   <br/>
The <code>:!{cmd}</code>command takes on a different meaning when it&rsquo;s given a range. The lines specified by <code>[range]</code> are passed as standard input for the <code>{cmd}</code>, and then the output from <code>{cmd}</code> overwrites the original contents of <code>[range]</code>.</li>
</ol>
</li>
<li>Manage Multiple Files

<ol>
<li> <code>:args</code>  argument list, represents the list of files that was passed as an argument when we ran the vim command.</li>
<li> <code>&lt;C - w&gt;s</code> divide the window horizontally   <code>&lt;C - w&gt;v</code> divide the window vertically. Each time we use these commands, the two resulting split windows will contain the same buffer as the original window that was divided.  <br/>
或者<code>:sp {filename}</code> 水平分割打开文件   <code>:vsp {filename}</code> 垂直分割打开文件   <br/>
<code>&lt;C - w&gt;w</code> cycle between open windows   <br/>
<code>:cl[ose]</code> or <code>&lt;C - w&gt;c</code>  close the active window   <br/>
<code>:on[ly]</code> or <code>&lt;C - w&gt;o</code>  keep only the active window, closing all others</li>
<li> <code>:tabe[dit] {filename}</code>  open {filename} in a new tab   <br/>
<code>:tabc[lose]</code> close the current tab page and all of its windows.  <br/>
<code>:tabo[nly]</code>   keep the active tab page, closing all othersa     <br/>
<code>tabn[ext]</code>  or gt  Switch to the next tab page</li>
</ol>
</li>
<li>Open Files and Save Them to Disk

<ol>
<li> <code>:edit %:h&lt;Tab&gt;</code>  Open a File Relative to the active file directory.  The <code>%</code> symbol is a shorthand for the filepath of the active buffer. The <code>:h</code> modifier removes the filename while preserving the rest of the path</li>
<li> <code>:e[dit] .</code> or <code>:E[xplore]</code> Open file explorer for the current working directory or the directory of the active buffer</li>
</ol>
</li>
<li>Navigate Inside Files with Motions

<ol>
<li> Real lines and Display lines     <br/>
<code>gj</code> <code>gk</code>  go down/up one display line.    <br/>
<code>g0</code> to first character of the display line    <br/>
也就是所有在display line上的操作都是以g开头的</li>
<li> <code>f{char}</code> <code>;</code> <code>,</code>  行内查找字符  重复  反向     <br/>
小技巧： When using the character search commands, it&rsquo;s better to choose target characters with  a low frequency of occurrences. 尽量选出现频率低的</li>
<li> <code>vi'</code> <code>va'</code>  区别是：第一个是inside，第二个是all. <code>cit</code> stands for &ldquo;change inside the tag&rdquo;</li>
<li> <code>iw</code>与<code>aw</code>的区别  <code>iw</code> stands for &ldquo;current word&rdquo;, while <code>aw</code> stands for &ldquo;current word plus one space&rdquo;. 因此，<code>aw</code>对象适合用于删除（d）操作，而<code>iw</code>适合用于修改（c）操作。</li>
<li> <code>m{a-zA-Z}</code> marks the current cursor location with the designated letter. Lowercase marks are local to each individual buffer, whereal uppercase marks are globally accessible. <code>'{mark}</code> moves to the line where a mark was set, positioning the cursor on the first non-whitespace character.<code>`{mark}</code>moves the cursor to the exact position where a mark was set.    <br/>
The <code>mm</code> and <code>'m</code> commands makes a handy pair. Respectively, they set the mark m and jump to it.</li>
<li> Surround.vim 插件，非常酷～ 一开始装了不起作用，后来发现是跟.vimrc配置中关于fcitx的设置有冲突，只能暂时不用fcitx的配置了。</li>
</ol>
</li>
<li>Navigate Between Files with Jumps

<ol>
<li> motions and jumps.  motions move around within a file, whereas jumps can move between files. jumps可以在文件之间跳转～</li>
<li> <code>&lt;C - i&gt;</code>  jump back   <br/>
<code>&lt;C - o&gt;</code> jump forth</li>
<li> <code>(/)</code> <code>{/}</code>  jump to start of previous/next sentence/paragraph</li>
<li> <code>H/M/L</code>  jump to top/middle/bottom of screen</li>
</ol>
</li>
<li>Copy and Paste

<ol>
<li> vim中使用<code>dd</code>或<code>yy</code>命令时，被复制或剪切的内容默认是放在未命名寄存器中的（unnamed register），若要指定特定的寄存器，需要<code>"{register}</code>，比如要复制内容到a寄存器，需要<code>"ayiw</code>，然后粘贴内容需要<code>"ap</code></li>
<li> 当我们使用复制命令时（<code>y{motion}</code>），特定的文本不仅被复制到未命名寄存器中，它同时也被复制到了复制寄存器（yank register），这个寄存器可以用<code>"0</code>来引用。</li>
<li> 黑洞寄存器（The Black Hole Register）。 在删除一些内容时，如果确定以后不会再使用它，那么为防止它污染当前的unamed register，可以用<code>"_</code>将它放入黑洞寄存器。 If we run the command <code>"_d{motion}</code>, then Vim deletes the specified text without saving a copy of it.</li>
<li> 系统寄存器和选择寄存器。 用于Vim外的程序与Vim共享内存。<code>"+</code>可以访问到系统中复制、剪切到剪切板的内容，而<code>"*</code>是专门针对Linux平台上的X11系统的，在X11系统中，内容只要被选中即被放在了系统剪切板中了，此时在Vim中可用<code>"*</code>寄存器访问。</li>
<li> 避免系统剪切板的内容剪切到Vim中出现太多缩进的情况。  这个问题的出现是由于autoindent特性的开启，如果此时需要在Insert模式下插入系统剪切板的内容，一个方法是先开启paste模式（<code>:set paste</code>），然后这时用鼠标中键粘贴就不会有问题了，不过记得用完要关掉paste模式（<code>:set paste!</code>）。更简单的方法是：直接在命令行模式下使用<code>"+p</code>或者<code>"*p</code>，不用管什么模式了。</li>
</ol>
</li>
<li>Macros

<ol>
<li> Series or Parallel 顺序还是并行</li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Python中的stdin stdout stderr]]></title>
    <link href="http://cs50Mu.github.io/blog/2014/10/07/io-in-python/"/>
    <updated>2014-10-07T10:29:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2014/10/07/io-in-python</id>
    <content type="html"><![CDATA[<p>看到一个题目，要求用Python实现linux中的命令tee的功能，tee的功能还是很简单的，就是把接收到的标准输入再输出到重定向和一个文件中。这些用Python来做应该不是什么难事，可是在Python里面怎么接收标准输入呢？</p>

<p>首先，有这样一个层级关系，<code>print</code>和<code>raw_input</code>这样的高级命令调用的是sys.stdin和sys.stdout，而sys.stdin和sys.stdout是file like object（类似于linux中一切设备皆文件），这一层的实现是Python的io模块。</p>

<p>下面通过两个例子可以清楚的看出print和sys.stdin和sys.stdout的关系。每个例子中第一句实现的效果跟后面的一沱实现的效果是一样一样的～</p>

<pre><code>######### stdout test ########
print 'hello world'

import sys
sys.stdout.write('hello world')

######### stdin test ########
print 'hi, %s' %raw_input('please input your name: ')

import sys
print 'please input your name: ',
name = sys.stdin.readline()[:-1]
print 'hi, %s' %name
#############################
</code></pre>

<p>比较好玩的事情是可以通过更改sys.stdin sys.stdout来实现类似linux中的重定向操作。比如默认stdout是终端，你可以在代码里通过<code>f = open(filename, 'w')</code> <code>sys.stdout = f</code>来把输出重定向到一个文件。</p>

<p>下面说下更底层的io模块。</p>

<p>像我们平时通过open等命令建立file like object后所使用的所有命令都是在io模块里实现的，比如write read readline seek flush等等。</p>

<p>io分三种类型：text I/O、binary I/O、raw I/O，以前总是傻傻分不清楚，现在终于理解了～</p>

<p>text I/O顾名思义，就是对我们人类来说能看到的、能识别的文字数据。无论什么数据都是以二进制的形式存储在计算机里的，但人类能识别的文字是以编码（assic、gbk、utf8）的形式存储在计算机里的，因为最终还要拿出来给人类读啊～～</p>

<p>binary I/O就是指所有非文本信息了，这类数据无需编码解码，也不用处理换行符，比如图片文件等。这个类型对应的open里的打开模式<code>'b'</code></p>

<p>raw I/O文档里说不常用，目前我也没理解它是干啥用的。。</p>

<p>最后，简陋的tee</p>

<pre><code>import sys 

def tee(filename):
    with open(filename, 'w') as f:
    for line in sys.stdin.readlines():
        sys.stdout.write(line)
        f.write(line)

if __name__ == '__main__':
    filename = sys.argv[1]
    tee(filename)
</code></pre>

<h3>参考</h3>

<ul>
<li><a href="http://en.wikibooks.org/wiki/Python_Programming/Input_and_Output">Python Programming/Input and Output</a></li>
<li><a href="http://woodpecker.org.cn/diveintopython/scripts_and_streams/stdin_stdout_stderr.html">标准输入、输出和错误</a></li>
<li><a href="https://docs.python.org/3.1/library/io.html#module-io">io — Core tools for working with streams</a></li>
<li><a href="http://5ydycm.blog.51cto.com/115934/304324">Python之sys模块小探</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[preparing for the job]]></title>
    <link href="http://cs50Mu.github.io/blog/2014/10/06/preparing-for-the-job/"/>
    <updated>2014-10-06T10:16:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2014/10/06/preparing-for-the-job</id>
    <content type="html"><![CDATA[<p>面试太渣，皆因毫无准备。</p>

<h3>多进程与多线程的区别</h3>

<ul>
<li>进程叫process，线程叫thread，cpu在任一时刻只能运行一个进程。一个进程可以包含多个线程</li>
<li>进程开销较大，线程开销较小</li>
<li>进程是<strong>资源分配</strong>的基本单位，线程是cpu调度的基本单位</li>
<li>进程有自己的地址空间，系统必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，是一种非常昂贵的多任务工作方式。而一个进程中的线程，它们之间共享大部分数据，使用相同的地址空间，因此切换线程比切换进程快的多，也就是说线程之间的通信比较方便，但从另一方面来说，如何控制线程对共享数据的访问又是一个难点了。</li>
<li>多进程程序比多线程程序要健壮。一个进程挂了，对别的进程基本不会有影响，但一个线程挂了，很可能会导致进程内的其它线程也挂掉。</li>
</ul>


<p>参考：
<a href="http://blog.csdn.net/morewindows/article/details/7392749">秒杀多线程第一篇 多线程笔试面试题汇总</a></p>

<h3>Python如何进行内存管理？</h3>

<ul>
<li>在一个对象的引用计数减为0时，对此对象进行内存回收</li>
</ul>


<p>参考：
<a href="http://www.cnblogs.com/vamei/p/3232088.html">Python深入06 Python的内存管理</a></p>

<h3>Python里如何拷贝一个对象？</h3>

<ul>
<li>首先要知道为什么要复制对象，因为在Python中无论是把对象作为参数传递还是作为函数返回值，都是引用传递的。那当我们不想传递引用的时候就要复制一个全新的对象了。</li>
<li>复制分为浅复制和深复制。浅复制是指只复制对象，但对象里的元素仍然使用引用。深复制（deepcopy）就是完完全全的复制了。</li>
</ul>


<p>参考：
<a href="http://blog.csdn.net/sharkw/article/details/1934090">深复制和浅复制</a></p>

<h3>RE模块中search和match的区别</h3>

<ul>
<li>match只搜寻第一个是否满足，若满足返回它，若不满足，则返回None</li>
<li>search搜索字符串，返回它遇到的第一个满足条件的，而不仅仅是查看第一个
注意这两个命令都是只返回一个满足条件的，要想返回所有满足条件的，要用findall</li>
</ul>


<p>参考：
<a href="https://docs.python.org/2/library/re.html#search-vs-match">search vs match</a></p>

<h3>用Python匹配HTML tag的时候，<code>&lt;.*&gt;</code>和<code>&lt;.*?&gt;</code>有什么区别？</h3>

<p>贪婪模式和非贪婪模式。
The <code>'*'</code>, <code>'+'</code>, and <code>'?'</code> qualifiers are all greedy; they match as much text as possible. Sometimes this behaviour isn’t desired; if the RE <code>&lt;.*&gt;</code> is matched against <code>'&lt;H1&gt;title&lt;/H1&gt;'</code>, it will match the entire string, and not just <code>'&lt;H1&gt;'</code>. Adding <code>'?'</code> after the qualifier makes it perform the match in non-greedy or minimal fashion; as few characters as possible will be matched. Using <code>.*?</code> in the previous expression will match only <code>'&lt;H1&gt;'</code>.</p>

<h3>python程序中文输出问题怎么解决？</h3>

<p>中文输出的问题都是由于编码问题。</p>

<p>中文字符串使用的编码与其所在的文件使用的编码一致。所以正确处理的步骤是：先用其原有编码decode成python内部的unicode，做了该做的处理后，什么时候想输出啦，这时候再使用encode，把它encode成任何想输出的编码形式。</p>

<h3>正则表达式匹配ip</h3>

<p><code>src = "security/afafsff/?ip=123.4.56.78&amp;id=45"</code>，请写一段代码用正则匹配出ip</p>

<pre><code>regx = re.compile(r'([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)')
m = regx.search("security/afafsff/?ip=123.4.56.78&amp;id=45")
m.groups()
('123', '4', '56', '78')
</code></pre>

<p>注意，使用groups可以返回找到的所有subgroups，非常方便。另外，group(0)返回整个匹配，group(1)返回第一个subgroup等等</p>

<h3>json</h3>

<p>写一段代码用json数据的处理方式获取{&ldquo;persons&rdquo;:[{&ldquo;name&rdquo;:&ldquo;yu&rdquo;,&ldquo;age&rdquo;:&ldquo;23&rdquo;},{&ldquo;name&rdquo;:&ldquo;zhang&rdquo;,&ldquo;age&rdquo;:&ldquo;34&rdquo;}]}这一段json中第一个人的名字。</p>

<pre><code>j = json.loads('{"persons":[{"name":"yu","age":"23"},{"name":"zhang","age":"34"}]}')
j.get('persons')[0]['name']
</code></pre>

<h3>平衡点</h3>

<p>比如int[] numbers = {1,3,5,7,8,25,4,20}; 25前面的总和为24，25后面的总和也是24，25这个点就是平衡点；假如一个数组中的元素，其前面的部分等于后面的部分，那么这个点的位序就是平衡点
我写出的版本，完全就是把题意翻译了一遍，能满足要求，效率应该不好</p>

<pre><code>def findMiddle(lst):
    for i in xrange(1, len(lst)-1):
    if sum(lst[:i]) == sum(lst[i+1:]):
        print i
</code></pre>

<p>看到别人的做法是，先算一遍总和，然后从左往右一个一个加，出现和一半的时候，说明找到平衡点了。</p>

<pre><code>def findMiddle2(lst):
    totle = sum(lst)

    add = 0 
    for i in xrange(0, len(lst)-1):
    add += lst[i]
    if totle - lst[i+1] == 2 * add:
        print i+1, lst[i+1]
</code></pre>

<h3>支配点</h3>

<p>支配数：数组中某个元素出现的次数大于数组总数的一半时就成为支配数，其所在位序成为支配点；比如int[] a = {3,3,1,2,3};3为支配数，0，1，4分别为支配点；</p>

<pre><code>def findDomain(lst):
    count = [ i for i,x in enumerate(lst) if lst.count(x) &gt; len(lst)//2 ]  # elegant solution
    if count:
    print lst[count[0]], count
</code></pre>

<h3>什么是PEP 8？</h3>

<p>Python编码规范</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[socks代理和http代理的区别]]></title>
    <link href="http://cs50Mu.github.io/blog/2014/10/05/socks-proxy-and-http-proxy/"/>
    <updated>2014-10-05T11:50:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2014/10/05/socks-proxy-and-http-proxy</id>
    <content type="html"><![CDATA[<p>一直傻傻分不清楚，都是因为平时很少接触，虽然翻墙常用，但也只是按教程一步一步来，并未知其所以然。</p>

<p>之前一直听别人说socks代理多么多么好，自己只是模模糊糊半懂不懂，现在终于切身体会到了一个好处，用socks代理后就没有证书问题的困扰了～～之前用的GoAgent使用的是http代理，每次访问https网站时，总是提示证书有问题，导入GoAgent的自带证书还是有问题，这下用了shadowsocks后一切都清净了。。为什么socks代理就这么牛逼呢？因为socks代理更底层，只负责发送接收数据，至于你是什么http ftp tcp udp它根本就不care。</p>

<ul>
<li>socks代理更底层，是在会话层；而http代理是在应用层。因此socks代理可以代理一切客户端的连接，而http代理只能代理使用http协议的客户端</li>
<li>由于更底层，不需要处理高级协议的细节，所以socks代理更快</li>
<li>socks协议分v4和v5版本，v4只能代理tcp协议，而v5什么协议都可以代理</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[binary search and spreadsheet numeration]]></title>
    <link href="http://cs50Mu.github.io/blog/2014/09/18/binary-search-and-spreadsheet-numeration/"/>
    <updated>2014-09-18T18:54:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2014/09/18/binary-search-and-spreadsheet-numeration</id>
    <content type="html"><![CDATA[<p>昨天去知道创宇的面试失败了，很感谢他们能给我这个机会。通过这次面试，我总算迈出了一步，更加明确了自己应该努力的方向。这次面试反映出的一个很严重的问题就是，手太生，学了这么长时间Python，竟然连一些常用的用法，命令都得现查文档。自己反思一下，没有自己动手写多少代码，这个是问题的关键。</p>

<p>面试我的雨哥人非常nice，面对我这么菜的表现没有一点不耐烦，他说的一句话让我印象深刻，“既然是有兴趣，平时就多花点时间，对得起兴趣这两个字”。我会的。</p>

<h2>二分法查找</h2>

<p>我想这个应该是最容易理解的算法了吧，我差点就在面试的时候完成了，well,almost&hellip;</p>

<p>思路很简单，因为给出的列表已经是排好顺序的了，因此直接找到中间的一个记为mid，若是要找的元素，任务完成。若mid比要找的元素大，好的，那么要找的元素肯定在start跟mid之间了，若mid比要找的元素小，那么要找的元素肯定在mid和end之间了。</p>

<pre><code>def binarySearch(lst, element, start, end):
    mid = (start + end)/2 
    if element == lst[mid]:
    print 'Found, %d' % mid 
    elif mid == start:
    if element == lst[mid+1]:  # 主要处理两个相邻的数的情况，这种情形下mid必然等于start
        print 'Found, %d' % (mid+1) # 因此如果end（也就是mid+1）不等于element的话，则没找到
    else:
        print 'Not found'
    elif element &gt; lst[mid]:
    return binarySearch(lst, element, mid, end)
    elif element &lt; lst[mid]:
    return binarySearch(lst, element, start, mid)

def binarySearch2(lst, element, start, end):
    mid = (start + end)/2
    if element == lst[mid]:
    return 'Found, %d' % mid 
    elif start &gt; end:
    return 'Not found'
    elif element &lt; lst[mid]:
    return binarySearch2(lst, element, start, mid-1)
    elif element &gt; lst[mid]:
    return binarySearch2(lst, element, mid+1, end)

def binarySearch3(lst, element):
    start = 0 
    end = len(lst) - 1
    while (start &lt;= end):
    mid = (start + end)/2
    if lst[mid] == element:
        return 'Found', mid
    elif lst[mid] &gt; element:
        end = mid - 1
    elif lst[mid] &lt; element:
        start = mid + 1
    return 'Not found'
</code></pre>

<p>上面的方法一是我自己瞎想的ugly思路，方法三是我在一站式C编程上看到的，方法二是我根据方法三的思路用递归改写的</p>

<h2>spreadsheet numeration</h2>

<p>这个题目其实我之前在CodeForces上做过的，可惜没有理解它的真谛，虽然当时误打误撞做出来了，还是没有效果，现在遇到还是不会做，面试中雨哥一句话点醒我，“进制转换”，是啊，这个问题实质上就是十进制转换26进制的问题。那进制转换无非就是要做除法、取余。但是也不是这么简单，有一个比较tricky的问题，就是在转换26的倍数的时候，需要做一些特殊处理才行。</p>

<pre><code>def numTochar(num):
    result = ''
    ori = num 
    while num:
    mod = num % 26
    if mod == 0:
        mod = 26
        num = num/26 - 1 # special cases for 'Z' 
    else:
        num /= 26
    result = chr(mod + ord('A') - 1) + result
    return result,ori

def numTochar2(num):
    result = ''
    ori = num 
    while num:
    mod = num % 26
    if mod == 0:
        mod = 26
    num -= 1       # a more elegant solution
    num /= 26
    result = chr(mod + ord('A') - 1) + result
    return result,ori
</code></pre>

<p>方法一是我自己捣鼓的，方法二是我在CodeForces上看到了，效果应该是一样的，都是为了在转换26的倍数的时候能够得出正确的结果，做出的一点特殊处理，不过显然后者更加优雅，每个数在除26之前先减1,这样既对于非26倍数的数没有影响，又能巧妙的处理26的倍数时的特殊情况。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Structure and Interpretation of Computer Programs]]></title>
    <link href="http://cs50Mu.github.io/blog/2014/07/26/sicp/"/>
    <updated>2014-07-26T22:59:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2014/07/26/sicp</id>
    <content type="html"><![CDATA[<p>大名鼎鼎的SICP，下面是我在学习Berkeley的CS61A时做的笔记,非常有意思的一门课！</p>

<h2>高阶函数</h2>

<p>理解这玩意儿有时候确实挺费脑筋。。。下面这个trick花了好久才理解。。关键一开始没想明白返回的到底是匿名函数还是匿名函数的执行结果</p>

<pre><code>def cons(a, b):
    return lambda m: m(a,b) # 此处返回的是一个参数为m的匿名函数！！并且m是一个函数，m接受两个参数a和b

def car(p):
    return p(lambda x,y:x) # 

car(cons(1,2)) # 结果应该为1
</code></pre>

<p>以上代码大概类似于下面的代码：</p>

<pre><code>def fuck(func):
    def wrapper(a,b):
        return func(a,b)
    return wrapper

x = fuck(lambda x,y:x)
x(1,2) # 输出1
</code></pre>

<h2>递归  破钱</h2>

<p>下面的函数实现的功能是，给定一个数值，比方说100块，和一堆小面额的纸币，找出用这些小面额纸币来表示这100块总共有几种方法。其中link函数是用来制作链表的，first函数返回链表的第一个元素，rest函数返回链表的剩余所有元素。可以看到函数是用递归实现的，依据大概是这样的：100块的表示方法可以分为两类，一类方法中使用链表中的第一个面额，另一类方法中不使用第一个面额。就这么简单。。。神奇的是它竟然是能工作的！</p>

<pre><code>def count_change(amount, denominations):
    '''
    Return the number of ways to make change for amount
    '''
    if amount &lt; 0 or denominations == empty:
        return 0
    elif amount == 0:
        return 1
    using_coin = count_change(amount - first(denominations), denominations)
    not_using_coin = count_change(amount, rest(denominations))
    return using_coin + not_using_coin

denominations = link(50, link(25, link(10, link(5, link(1, empty)))))
&gt;&gt;&gt; print_linked_list(denominations)
&lt; 50 25 10 5 1 &gt;
&gt;&gt;&gt; count_change(100, denominations)
292
</code></pre>

<h2>ADT(Abstract Data type)</h2>

<p>ADT也属于抽象的一种，目的是控制复杂度，把复杂并且与下面要实现的功能无关的细节隐藏起来，只把几个关键的东西暴露给外部，要形成一个ADT一般需要一个constructor，一个selector，一个mutator等，有了这些，外部就可以用它们进一步实现别的功能了，像链表啊，树啊都属于ADT。其中，deep list和tree属于hierarchical data structure</p>

<h2>Implicit Sequences</h2>

<p>a sequence can be represented <strong>without</strong> each element being stored explicitly in the memory of the computer. That is, we can construct an object that provides access to all of the elements of some sequential dataset without computing all of those elements in advance and storing them. Instead, we compute elements on demand. 很巧妙的一种实现方式，不是把元素全部计算出来放在内存里等着去取，而是需要的时候才计算一个出来，这样可以节省大量的内存。这在计算机科学中叫lazy computation(lazy computation describes any program that delays the computation of a value until that value is needed). 但注意，实现这个强大功能的前提是sequential access(相对于random access)，也就是说只能按顺序依次获取，不能想取哪个就取哪个。嗯，iterator就是在这个背景下诞生了。。An iterator is an object that provides <strong>sequential access</strong> to an underlying sequential dataset. iterator就是为了方便处理那些具有内在顺序结构的数据而诞生的。The iterator abstraction has two components: a mechanism for retrieving the next element in some underlying series of elements and a mechanism for signaling that the end of the series has been reached and no further elements remain. In programming languages with built-in object systems, this abstraction typically corresponds to a particular interface that can be implemented by classes.</p>

<ul>
<li>iterators与iterables</li>
</ul>


<p>原来这两个不是一个东西。iterators需要实现<code>__next__</code>方法，是具体干活的。   <br/>
An object is iterable if it <strong>returns an iterator</strong> when its <code>__iter__</code> method is invoked. Iterable values represent data collections, and they provide a fixed representation that may produce more than one iterator. iterator和iterable类似于类和实例的关系吧,iterator负责实现模型、架构，iterable负责实例化。For example, an instance of the <code>Letters</code> class below represents a sequence of consecutive letters. Each time its <code>__iter__</code> method is invoked, a new <code>LetterIter</code> instance is constructed, which allows for sequential access to the contents of the sequence.</p>

<pre><code>&gt;&gt;&gt; class LetterIter:
    """An iterator over letters of the alphabet in ASCII order."""
    def __init__(self, start='a', end='e'):
        self.next_letter = start
        self.end = end
    def __next__(self):
        if self.next_letter == self.end:
        raise StopIteration
        letter = self.next_letter
        self.next_letter = chr(ord(letter)+1)
        return letter

&gt;&gt;&gt; class Letters:
    def __init__(self, start='a', end='e'):
        self.start = start
        self.end = end
    def __iter__(self):
        return LetterIter(self.start, self.end)

&gt;&gt;&gt; b_to_k = Letters('b', 'k')
&gt;&gt;&gt; first_iterator = b_to_k.__iter__()
&gt;&gt;&gt; next(first_iterator)
'b'
&gt;&gt;&gt; next(first_iterator)
'c'
&gt;&gt;&gt; second_iterator = iter(b_to_k)
&gt;&gt;&gt; second_iterator.__next__()
'b'
&gt;&gt;&gt; first_iterator.__next__()
'd'
&gt;&gt;&gt; first_iterator.__next__()
'e'
&gt;&gt;&gt; second_iterator.__next__()
'c'
&gt;&gt;&gt; second_iterator.__next__()
'd'
</code></pre>

<p>但是！在Python中<code>__next__</code>和<code>__iter__</code>方法是在同一个类中的！To use an iterator in a for loop, the iterator must also have an <code>__iter__</code> method. The <a href="http://docs.python.org/3/library/stdtypes.html#iterator-types">Iterator types</a> section of the Python docs suggest that an iterator have an <code>__iter__</code> method that returns the iterator itself, so that all iterators are iterable. 只要理解了<code>__iter__</code>方法的作用，也很容易理解的啦。</p>

<ul>
<li>Generators and Yield Statements</li>
</ul>


<p>Generators属于Iterator，a generator is an <strong>iterator</strong> returned by a special class of function called a generator function. Generator functions are distinguished from regular functions in that rather than containing return statements in their body, they use yield statement to return elements of a series.</p>

<p>The Letters and Positives objects above require us to introduce a new field self.current into our object to keep track of progress through the sequence. With simple sequences like those shown above, this can be done easily. With complex sequences, however, it can be quite difficult for the <code>__next__</code> method to save its place in the calculation. Generators allow us to define more complicated iterations by leveraging the features of the Python interpreter.</p>

<p>Generators do not use attributes of an object to track their progress through a series. Instead, they control the execution of the generator function, which runs until the next yield statement is executed each time the generator&rsquo;s <code>__next__</code> method is invoked. The Letters iterator can be implemented much more compactly using a generator function. 虽然实现的功能是一样的，但Generators与iterators的实现机理是不一样的，yield的机理貌似是coroutines，到底是个神马东东，待查。</p>

<pre><code>&gt;&gt;&gt; def letters_generator():
    current = 'a'
    while current &lt;= 'd':
        yield current
        current = chr(ord(current)+1)

&gt;&gt;&gt; for letter in letters_generator():
    print(letter)
a
b
c
d
</code></pre>

<p>Even though we never explicitly defined <code>__iter__</code> or <code>__next__</code> methods, the yield statement indicates that we are defining a generator function. When called, a generator function doesn&rsquo;t return a particular yielded value, but instead a generator (which is a type of iterator) that itself can return the yielded values. A generator object has <code>__iter__</code> and <code>__next__</code> methods, and each call to <code>__next__</code> continues execution of the generator function from wherever it left off previously until another yield statement is executed.</p>

<p>The first time <code>__next__</code> is called, the program executes statements from the body of the <code>letters_generator</code> function until it encounters the yield statement. Then, it pauses and returns the value of current. yield statements do not destroy the newly created environment, they preserve it for later. When <code>__next__</code> is called again, execution resumes where it left off. The values of current and of any other bound names in the scope of <code>letters_generator</code> are preserved across subsequent calls to <code>__next__</code>.</p>

<p>这样，可以用yield语句来简化iterables的写法</p>

<pre><code>&gt;&gt;&gt; class LettersWithYield:
    def __init__(self, start='a', end='e'):
        self.start = start
        self.end = end
    def __iter__(self):
        next_letter = self.start
        while next_letter &lt; self.end:
        yield next_letter
        next_letter = chr(ord(next_letter)+1)
</code></pre>

<p>以前没有Generators的时候，还需要定义一个<code>__next__</code>方法来生成iterator，然后用<code>__iter__</code>方法来返回self，这下因为yield本身返回的就是一个Generator(也属于Iterator)，所以无需<code>__next__</code>方法来生成iterator。</p>

<h2>Mutation in for loops</h2>

<p>如果在for循环中对对象做了修改（增加或删除），会出现无法预测的结果</p>

<pre><code># Demo: Mutation in For Loops
# lst = list(range(10, 20))
# for item in lst:
#     print(item)
#     lst.remove(item)
# lst
# 下面是解决办法, 不过原理未搞懂，待查
class BetterList(list):
    def __iter__(self):
    return list.__iter__(self[:])
</code></pre>

<h2>nonlocal与list</h2>

<p>看下面两段代码</p>

<pre><code>def make_accumulator():
    """Return an accumulator function that takes a single numeric argument and
    accumulates that argument into total, then returns total.
    """
    total = []
    def accumulator(amount):
    total.append(amount)
    return sum(total)
    return accumulator

def make_accumulator_nonlocal():
    """Return an accumulator function that takes a single numeric argument and
    accumulates that argument into total, then returns total.
    """
    total = 0
    def accumulator(amount):
    nonlocal total
    total += amount
    return total
    return accumulator
</code></pre>

<p>为何单个变量(total)在&#8221;全局&#8221;访问的时候需要nonlocal参数，而列表就不用了呢？</p>

<h2>format method of strings</h2>

<pre><code>&gt;&gt;&gt; 'I {0}, you {0}, we all {0} for {1}!'.format('scream', 'ice cream')
'I scream, you scream, we all scream for ice cream!'
</code></pre>

<h2>Generic Functions</h2>

<p>Generic functions are methods or functions that apply to arguments of different types. 我理解就是不管对象类型是不是一样，都可以用这个通用函数来做运算。Generic functions主要有下面三种实现方式：
&ndash; Interfaces
&ndash; Type dispatching
&ndash; Coercion</p>

<h2>Memoization</h2>

<p>Keep track of all the calls we have ever made to fib and their answers. Then when we made a repeated recursive call, we immediately return the answer.</p>

<h2>Huffman Encoding</h2>

<p>一种可变编码方式，可针对词频进行优化编码，出现次数多的字母用相对小的位数来编码，出现次数多的字母用相对多的位数来编码，这样相对于固定位编码方式可节省存储空间。  <br/>
使用方法：</p>

<ul>
<li>统计字母出现频率，并据此创建霍夫曼二叉树。创建的方法就是对给定的字母、频率，不停的merge掉频率最小的两个，并根据这两个生成一个新的HuffmanTree，它的频率为那两个频率最小的频率之和，以此直至只剩下两个HuffmanTree为止.</li>
<li>编码</li>
<li>解码
编码和解码部分可用递归优雅的实现

<h2>Scheme</h2></li>
<li>区分symbol和string. When you type things in the interpreter, Scheme will evaluate it. The rule for evaluating a symbol is to get the value bound to that symbol. This is one difference between strings and symbols&mdash;symbols don&rsquo;t evaluate to themselves(which strings do). However, as you saw above, when you type in &lsquo;a, you get a. This is because when you use single quote, you&rsquo;re telling Scheme <strong>not to follow</strong> the normal rules of the evaluation and just have the symbol return as itself.</li>
<li>Special Forms. 类似于其它语言中的关键字，比如define if and or等等</li>
<li>Lambdas. 语法： <code>(lambda (&lt;PARAMETERS&gt;) &lt;EXPR&gt;)</code></li>
<li>Functions. 语法：<code>(define (&lt;FUNCTIONNAME&gt; &lt;PARAMETERS&gt;) &lt;EXPR&gt;)</code>. Python will automatically transform it to <code>(define &lt;FUNCTIONNAME&gt; (lambda (&lt;PARAMETERS&gt;) &lt;EXPR&gt;)</code> for you.所以在Scheme中，lambda更基础.</li>
<li>关键字let. 语法：
  (let ( (<SYMBOL1> <EXPR1>)
      &hellip;
      (<SYMBOLN> <EXPRN>) )
      <BODY> )
它等价于：<code>( (lambda (&lt;SYMBOL1&gt; ... &lt;SYMBOLN&gt;) &lt;BODY&gt;) &lt;EXPR1&gt; ... &lt;EXPRN&gt;)</code></li>
<li>Pairs. 创建：<code>(define a (cons 1 2))</code> 获取： <code>(car a)</code> <code>(cdr a)</code></li>
<li>List. A List is a specific kind of Pair that is either nil(an empty list) or a Pair whose cdr is another List. 比如，(cons 1 (cons 2 nil))，它可以简写成&#8217;(1 2)，检查List是否为空可用null?语句</li>
</ul>


<h2>Tail Recursion 尾递归</h2>

<p>是对递归的一种优化，我们都知道，一般线性递归在新的调用之前需要在堆栈中保存当前调用的信息，这样随着函数调用的增多，对内存的占用会越来越大，而尾递归能够实现这一次的调用使用的堆栈空间直接覆盖上次用过的，因此虽然函数调用在不断进行，但对内存的占用却是不变的！（linuxfish注：看了一堆介绍，我肿么觉得尾递归有点过程语言中循环的感觉，是不是因为函数式编程中没有循环，才用尾递归的？）</p>

<p>注意，要区分尾递归语法和尾递归优化，也就是说，你可以把递归写成尾递归的形式，但底层（解释器、编译器）是否给你优化就不一定了。比如，Python可以写成尾递归的形式，但是没用，照样会stackoverflow，因为解释器并不支持。</p>

<h2>Streams</h2>

<p>这应该是Python中generator的鼻祖了吧。Streams are a clever idea that allows one to use sequence manipulations without incurring the costs of manipulating sequences as list. With streams we can achieve the best of both worlds: We can formulate programs elegantly as sequences manipulations, while attaining the efficiency of <strong>incremental computation</strong>. The basic idea is to arrange to construct a stream only partially, and to pass the partial construction to the program that consumes the stream. If the consumer attempts to access a part of the stream that has not yet been constructed, the stream will automatically construct just enough more of itself to produce the required part, thus preserving the illusion that the entire stream exists. In other words. In other words, although we will write programs as if we were processing complete sequences, we design our stream implemention to automatically and transparently interleave the construction of the stream with its use.感觉这玩意儿纯粹是Schemer们妄图所有问题都用list pair来解决，发现不行后又整出来的一个东东。这也是所谓的函数式语言的懒惰特性，所谓懒就是不到万不得已不动弹。。而不是傻乎乎的一下子就把整个list都计算出来。</p>

<h2>Declarative Programming</h2>

<p>比如SQL语言</p>

<p>data values are often stored in large repositories called databases. A database consists of a data store containing structured data values and an interface for retrieving subsets of the data based on their characteristics. Each value stored in a database is called a record. Records are typically retrieved via a query, which is an expression in a query programming language. By far the most ubiquitous query language in use is called Structure Query Language or SQL.</p>

<p>SQL is an example of a declarative programming language. Expressions do not <strong>describe computations directly</strong>, but instead state the form of the <strong>result</strong> of some computation. It is the role of the <strong>query interpreter</strong> of the database system to design and perform a computational process to produce such a result.</p>

<p>This interaction differs substantially from the procedural programming paradigm of Python or Scheme. In Python, <strong>computational processes are described directly by the programmer.</strong> A declarative language specifies the form of the result, but abstracts away procedural details.</p>

<h2>Concurrency 并行</h2>

<ul>
<li>并行是一个现实问题，生活中经常会遇到，又是一个提升效率的好办法，并行办事比串行等待效率要高很多！</li>
<li>由于线程并行所导致的问题可以通过引入锁的机制来解决，不过要注意防止死锁现象。</li>
<li>还可以通过Message Passing来解决</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[捣鼓VPS翻墙]]></title>
    <link href="http://cs50Mu.github.io/blog/2014/07/14/my-first-vps/"/>
    <updated>2014-07-14T22:19:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2014/07/14/my-first-vps</id>
    <content type="html"><![CDATA[<p>在学校论坛上看到有人介绍在vps上搭建shadowsocks服务器来翻墙，看到他推荐的vps很便宜，一年才20多，于是立马也想买一个了，其实以前就想折腾vps的，无奈找到的vps价格都太高，一个月要几百块神马的，像我这么小气的人肿么可能舍得。。不过，这个实在是太便宜了啊，虽然配置是最低的了，72M内存，2G硬盘，但一个月有100G的流量，对于翻墙来说够用了，果断注册下单购买，只支持PayPal支付，于是又注册PayPal，在这上面折腾了很久，一开始注册成中国版的了，结果提示无法跨境支付，放狗搜索后发现，需要注册国际版的，以为还要审核神马的，结果直接绑定银行卡后就可以支付了，很方便啊！</p>

<p>可是才用一天就被墙了！！我目前使用的是长城宽带的服务，ssh都无法登陆了，但后来发现使用学校自己的外网还是可以用的，学校的外网应该是用的联通的服务，后来我到V2EX上问了下发现有人用长城宽带的服务也有类似的问题，该死的长城宽带！</p>

<h2>更新（20141002）</h2>

<p>不久前听人说Bandwagon出加州机房了，一直懒得弄，今天花时间看了下，果然有加州机房了，果断迁移过去，给换了个新ip，然后shadowsocks不能用了，一开始以为是shadowsocks服务器端没开，后来发现是服务器端的设置里ip也需要更新下才行。</p>

<p>正好记录下shadowsocks服务器端的配置，省得下次再忘。</p>

<ul>
<li>shadowsocks在服务器端是以daemon形式运行的。daemon脚本在<code>/etc/init.d/shadowsocks</code>，配置文件在<code>/etc/shadowsocks/config.json</code></li>
<li>要启动/关闭/重启shadowsocks，只需在命令行执行<code>/etc/init.d/shadowsocks start/stop/restart</code>，它默认开始是自启动的。</li>
<li>刚刚才知道，原来shadowsocks是socks代理，因此可以无压力访问https网站，再也不会遇到GoAgent一样的证书问题了～～哈哈，真好</li>
</ul>


<p>对了，火狐代理插件换成foxyproxy了，autoproxy已经好久不更新，基本无法使用了，之前一直迟疑不想换是因为听说foxyproxy配置比较麻烦，今天试了试才发现对于经常折腾的人来说根本就不是事～～ foxyproxy也支持订阅gfwlist列表，于是生活又美好起来了～～</p>

<h2>参考</h2>

<ul>
<li><a href="https://github.com/madeye/shadowsocks-libev">shadowsocks-libev</a></li>
<li><a href="http://www.lucong.com.cn/lulu/centos-debian-shadowsocks-libev.html">CentOS、Debian下搭建shadowsocks-libev服务端</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[冒泡排序和插入排序]]></title>
    <link href="http://cs50Mu.github.io/blog/2014/03/30/two-sort-algorithms/"/>
    <updated>2014-03-30T20:07:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2014/03/30/two-sort-algorithms</id>
    <content type="html"><![CDATA[<h2>冒泡排序</h2>

<p>应该是最简单的吧，但是效率很低。对于给定的n个无序数列，不断的比较相邻的两个数的大小，若满足条件，则互换两个数的位置，这样经过一次循环后，最大的（或者最小的）数就冒出来了，经过n次循环，顺序就排好了。具体伪代码如下：</p>

<pre><code>    for(i=0; i &lt; n; i++) {
            for(j = 0; j &lt; n - i - 1; j++) {
                    if(target[j] &gt; target[j+1]) {
                            temp = target[j+1];
                            target[j+1] = target[j];
                            target[j] = temp;
                    }   
            }   
    }   
</code></pre>

<h2>插入排序</h2>

<p>模仿的是打牌的时候，插牌的方法。对于给定的n个无序数列，从第二个数开始往下循环到第n个数，在处理某个数的时候，依次比较这个数跟它之前的数的大小，直到找到合适的位置后就插入。具体伪代码如下：</p>

<pre><code>    for(i = 1; i &lt; n; i++) {
            key = target[i];  // 待插的值
            for(j = i - 1; (j &gt;= 0) &amp;&amp; (target[j] &gt; key); j--) {
                    target[j+1] = target[j];   // 移位，给要插入的数让位
            }
            target[j+1] = key;    // 插进去
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重新学习C]]></title>
    <link href="http://cs50Mu.github.io/blog/2014/03/28/relearning-c/"/>
    <updated>2014-03-28T20:14:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2014/03/28/relearning-c</id>
    <content type="html"><![CDATA[<p>发现写learn python the hard way的大神Zed.A.Shaw的the hard其实是一个系列，除了python还有Ruby、C、SQL、Regex，都是我想学的有木有！这几天在看他的C的教程，虽然只是一个alpha版本，但已经很牛逼了啊，一开始还可以，现在光是消化一小节都要好几天好不好！看了他的教程，感觉自己以前学过的那点东西真的是连屎都不如。。anyway，学到了很多东东，记录下学到的东西。</p>

<ul>
<li>指针。发现在实际使用中很容易把指针变量和指针所指的内容搞混，要记住，指针变量里存放的只是一个地址而已，所以它的大小（位数）是固定的，应该是4个字节，跟它所指的内容没有一点关系。比如我在练习中遇到的一个问题是，有一个结构体，结构体有几个字符型指针，也就是说这几个指针是指向几个字符串的，然后在给这个结构体申请空间的时候我就晕了。。到底应该申请多少呢？直接malloc(sizeof(struct Address))吗？因为我总纠结着结构体里的字符型指针，想着这几个指针指向的字符数目又没有定，这可怎么办呢？其实是我想多了，把指针和它指向的内容混淆了，要知道，指针就是指针而已，大小固定，4个字节，所以上面那个结构体的大小是固定的，可以直接用sizeof来计算。至于那几个指针指向的字符串嘛，等要用的时候再malloc就可以了，也就是说它们跟上面说的结构体没半毛钱关系！只是因为里面有个指针指向了它们而已。</li>
<li>内存管理。这个之前真的是没有想过，也没有遇到过。因为总是在用一些脚本语言，根本就没有关注过内存管理的问题，导致现在遇到都不知道该怎么处理了，现在通过一次练习，对内存管理有了一些理解了。基本上，在C中一切内存管理都要自己来，要放东西的时候就要自己malloc申请空间，不需要提前申请，只要在需要使用的时候申请就行了，然后记得申请的空间用完后要自己释放，否则会导致内存泄露！</li>
<li>动态数据结构从文件的读取和写入。乍一想觉得挺简单，其实还是蛮复杂的好不好。。先说写入，这里说的动态结构是指用指针实现的，就是不是固定的数组，所以具体大小可以到时候malloc随意申请，灵活是灵活，但要写入文件的时候就SB了，不能像固定结构那样直接一个<code>fwrite(&amp;addr, sizeof(struct Addr), 1, fpr)</code>就行了好不好，你要自己找到指针指向的内容，然后一个一个自己写啊！再说读取，首先顺序要一致，怎么写入的就要怎么读取出来，否则肯定是没戏啊，然后读取的时候要先准备好地方啊！也就是说要为读入的数据用malloc提前申请空间啊！还有一个就是一次读入数据大小的问题，这个要好好弄清楚，我在练习的时候就是这个没弄清楚，导致程序一直都有问题，还是那句话，不要把指针和指针指向的内容混淆！！</li>
<li>gdb。gdb是个神器！！</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[统计浏览器历史记录]]></title>
    <link href="http://cs50Mu.github.io/blog/2014/03/03/get-your-visit-internet-frequency-by-python/"/>
    <updated>2014-03-03T19:13:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2014/03/03/get-your-visit-internet-frequency-by-python</id>
    <content type="html"><![CDATA[<p>又是好久没更新。</p>

<p>知乎是个好网站。那么多大牛分享自己的经验教训～涉及范围包罗万象，无所不有。对我而言，很重要的一点是它拓展了我的眼界，让我知道，哦，原来还可以这么想，事情还可以这么做，这世界上原来还有这样一种活法。。</p>

<p>逛知乎的时候还是不由自主的看起编程方面的提问了，其中有一个问题是“用python可以做哪些有趣的事？”看到大家各种有趣的分享，我想这真是太酷了！一直以来，虽然对编程很感兴趣，但总是深入不进去，刚刚有点想法的时候，可总是考虑的太复杂，牵扯的知识点太多，然后要看很多东西，最后热情就这么一点点被消磨掉了，然后就是扔下好久不去想它，直到某天忽然又有热情了，如此循环往复。。看似做了很多，其实却一直在原地踏步。看了这么多知乎牛人的回答后，有了一点点启发，也有了具体的指导，那么就按各位大牛的做法来试试，从自己感兴趣的、容易实现的小玩意儿开始吧。</p>

<p>要统计浏览器的访问记录，首先要找到访问记录，看起来简单，以为只要随便导出一下就可以了，实际还颇费了一番周折。火狐的历史记录以前是以xml格式存储的，现在则是用数据库格式存储的，位置是在<code>%appdata%\Mozilla\Firefox\Profiles\xxxxx.default\places.sqlite</code>。东西是找到了，可是肿么读出来呢？尼玛是数据库文件啊，我还不会用肿么办呢？google了一番后发现可以用firefox的一个扩展来打开读取，这个扩展叫SQLite Manager，相当赞，各种功能齐全，关键支持csv导出！好的，长话短说，导出为csv文件后就可以请python出场了！</p>

<p>基本步骤是，先从csv文件中按行读出来，这数据库还是蛮大的，共13692条记录，然后从行中提取出需要的网址信息，放入一个列表中，然后再利用字典来统计各个网址的频度，程序如下：</p>

<pre><code>#!/usr/bin/python

import csv
histList=[]
histDict={}
with open('f:\moz_places.csv','rb') as f:
    reader = csv.reader(f)
    for row in reader:
    histList.append('/'.join((row[1].split('/'))[:3]))


for place in histList:
    if place not in histDict:
    histDict[place] = 1
    else:
    histDict[place] += 1

sortedDict = sorted(histDict.iteritems(),key=lambda d:d[1],reverse=True)

for (place,freq) in sortedDict[:50]:
    print '%s\t\t%s' %(freq,place)
</code></pre>

<p>PS，再总结下这几天学到的新东西：</p>

<ul>
<li>splinter。python下的一个网页应用测试库，就是可以操纵浏览器来与网站交互，玩了下还挺好上手，比底层一点的request神马的友好多了，之前还一直坚持不用这种直接操作浏览器的库，嫌太低端，现在看来，还是先从基础开始慢慢来吧。</li>
<li>xpath。一种选择xml文件中节点的方法，通过它可以快速指定html文件中的元素。</li>
<li>css selector。也是为了简化css而出现的，通过它也能快速指定网页中的特定元素。</li>
</ul>


<p>以上两个玩意儿的语法并不是很难，阮一峰的博客中都有介绍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[last day of 2013]]></title>
    <link href="http://cs50Mu.github.io/blog/2013/12/31/last-day-of-2013/"/>
    <updated>2013-12-31T17:23:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2013/12/31/last-day-of-2013</id>
    <content type="html"><![CDATA[<p>今天是2013年最后一天了，不经意间一年又过去了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[五儿子到手了！]]></title>
    <link href="http://cs50Mu.github.io/blog/2013/12/01/nexus5-has-arrived/"/>
    <updated>2013-12-01T20:54:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2013/12/01/nexus5-has-arrived</id>
    <content type="html"><![CDATA[<p>在拿到包裹的时候竟然异常的平静，或许是因为早已经麻木了。对了，感谢政府感谢党，没有睡我。</p>

<p>回顾下整个购买过程：11月20号在日本google play下单，11月21日晚上8点多收到易票联的手机扣款的短信通知，11月22日收到谷歌的发货通知，手机是从香港发出的，11月25日收到转运公司的商品签收通知和转运费用通知，立马通过支付宝付款（才77多），当晚收到付款完成通知，11月26日收到转运公司的商品寄出通知，是用EMS寄的，查询EMS记录显示，手机在11月26日晚上6点被寄出，27日到达北京，28日到达天津，然后当天就送到学校了！！这个速度是让我很吃惊的，国内的EMS突然这么快都让我有点不适应了。。28号那天不停的刷EMS进度，然后看到状态突然从到达处理中心，跳到投递并签收，我和我的小伙伴都惊呆了！赶紧跑到学校收发室，看记录，没有，然后被告知，刚到的邮件还没有登记！又等了一会儿，终于登记完了，过去一看，果然有！！</p>

<p>这样算下来，整个购买从下单到拿到手总共才9天不到！跟美淘比快多了，虽然就是价钱贵了一点点。但是呢，因为第一次海淘，花费的时间成本还挺大的，回头看看，整整一个月搭进去了，从11月初刚发布，就确定要买，只是那时候还期待淘宝呢，后来发现可以海淘，于是就想试试，谁知道是个坑啊，呵呵～～个中辛酸已经在上一篇博客中发过牢骚了，现在只总结下问题，告诫自己不要再犯错误。</p>

<ul>
<li>信用卡。这个是最重要的！！一开始就是死在这上面的！google钱包里注册的信用卡信息必须真实，还必须得是本人的卡，姓名和电话什么的一定要填真实自己的，地址因为没办法选天朝，所以只能用转运公司的。我一开始用朋友的卡，购买人填的我，信用卡信息填的朋友的，也通不过！这时候就看到自己有信用卡的重要性了，借别人的，一个是不方便，不安全；另一个是可能根本就没法下单。。后来实在没办法，看到贴吧里有吧友用易票联支付成功了，才终于支付成功。易票联是一种虚拟信用卡，可以用于境外支付，没有信用卡的同学可以试试它，注册也很方便，立马就能用，不过最好是认证下，我一开始没有实名认证，下单好久都没反映，实名认证人工审核可能需要一两天，也很快。还有就是，通过信用卡网上买东西会有一个提前的扣款，叫预授权扣款，这个不是实际的商品扣款，到时候是会自动返还回来的，不用担心。</li>
<li>VPN。为了海淘专门买了一个月的VPN，因为境外的网站不认中国ip，需要挂vpn才能下单成功，而且最好不要老是更改访问的ip，很容易出问题。</li>
<li>google账户。这个我觉得也是一个问题，一开始我没有申请新的google账户，就用的以前一直用的老账户，一直没有成功，后来重新申请了一个全新的账户才成功了。</li>
</ul>


<p>应该就是这几个问题了，感慨下日淘真的很快啊～！相比较美淘要1个多月，日淘真的是神速啊！而且貌似被睡的几率还很小。以后海淘的话优先选择日淘～～</p>

<p>最后，拿到nexus 5的那一刻，感觉一切的煎熬与等待都值了，因为五儿子真的是太酷了～～拿到五儿子后以前的手机都不忍直视了。。</p>

<p>对了，给五儿子配了张联通3G卡，平生第一次用3G卡，体验还不错，就是淘宝卖家太坑，买前买后180度大变脸，买前亲啊亲啊的叫的好甜啊，付钱后就愛搭不理的，说的很清楚要求剪卡，没剪就送来了，然后还强词夺理不想负责。。还有，这卡应该是假的，卖家承诺的那些返话费可能都没那么久，我之前已经在网上看过很多类似的抱怨，但没办法营业厅里的套餐太贵，用不起。。暂时先买了这个，如果被骗，算个教训，以后淘宝购物一定要谨慎！X宝JS果然不是谣传。2013年12月1日正式开始用的这张联通卡，花了213大洋，我倒要看看到底能用到什么时候，后续会更新。</p>

<p>谨以此献给我的第一次海淘～～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最近各种不顺]]></title>
    <link href="http://cs50Mu.github.io/blog/2013/11/20/bad-days/"/>
    <updated>2013-11-20T20:30:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2013/11/20/bad-days</id>
    <content type="html"><![CDATA[<p>最近一个月都不在状态。</p>

<p>也许是因为停止跑步了？天气一冷就懒得跑了。。唉，最终还是没有坚持下去。</p>

<p>最可恨的是买个谷歌5儿子，从月初就开始买，直到现在愣是没买成功。。唉，搞得我都无力吐槽了，不过也算是知道海淘是怎么回事了。。唉，建议心理承受能力不行的还是别掺和了，虐心啊！因为nexus在伟大的天朝根本不上市，所以只能国外海淘，本来是想去美国google play淘的，贴吧里研究了一下，看到有人说在日本google play下单发货快，虽然要比美国的价格贵多了，但算上运费啥的也贵不了多少。海淘还必须得有国外的ip才行，为了这个还专门买了一个月的vpn帐号，然后注册转运公司。哦，先说下海淘的流程吧，基本工具要有，vpn用来做代理，信用卡用来支付。首先，你得注册一个转运公司，获取到一个你的转运地址，然后去国外google play上下单，用信用卡付款，送货地址就填你注册转运公司获取到的地址，然后就等吧，扣款成功后一般就会发货了。唉，哥就悲剧的卡在付款这个环节上了，一开始是没有信用卡，到处借卡，其实我之前有一张信用卡，但因为年费太高被我注销了。。好不容易借到一张卡，不管怎么填账单信息，google就是不扣款。。别人不是一下订单就扣款就是等了没多久就扣款，可我的订单就是没一点动静。。后来又看到贴吧里有人说没信用卡的用易票联的虚拟信用卡也支付成功了，于是又赶紧注册易票联，手机的钱也打进易票联了，更新名字和电话为自己的真实信息，地址因为无法选中国，只能用转运公司的了，所有这些做完后竟然还是不行！！！跟我同一天下订单的人，人家都收到发货通知了，我的还是一点动静都没，唉，感觉不能再爱了。。</p>

<p>然后就因为一直挺期待五儿子的，搞得每天都没心思了学习了有木有！！感觉好久都没看书了，英语跟读也好久没有进行了。</p>

<p>最后，祸不单行，服务器最近也问题不断，一开始是被顶ip，后来竟然升级到MAC攻击。。还专门在半夜10点11点的时候，也不知道到底是有人故意的还是有人电脑中病毒了，昨天外网网线竟然被剪了，当时听到这个消息我就震惊了，这真是不碰上不知道，什么样的奇葩都有啊。。</p>

<p>吐了这么多槽，其实还是有点好事的，经某大神指点发现宽带竟然可以多拨～～于是，生活又美好了一点点。</p>

<p>以上      by 快要崩溃感觉无法再爱的linuxfish</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[3 amazing days at mangoo hotel]]></title>
    <link href="http://cs50Mu.github.io/blog/2013/10/29/3-amazing-days-at-mangoo-hotel/"/>
    <updated>2013-10-29T20:20:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2013/10/29/3-amazing-days-at-mangoo-hotel</id>
    <content type="html"><![CDATA[<p>2013.10.24-2013.10.27</p>

<p>What happened in these 3 days is a milestone in my life. Thank you, my lover. It&rsquo;s very lucky of me to meet you! Although we both know that we may not end up well eventually, for sure you will be my angel forever. At one moment I thought I would end up all by myself during my entire life, then you came up, brought me this fresh new world!</p>

<p>It&rsquo;s you who makes me realize that if you wanna a change you&rsquo;ve got to make a move first! During the past some twenty years, I was always thinking too much without making any actual moves.</p>

<p>Finally, many thanks for your great patience, baby!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[understand octopress]]></title>
    <link href="http://cs50Mu.github.io/blog/2013/10/13/understand-octopress/"/>
    <updated>2013-10-13T17:42:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2013/10/13/understand-octopress</id>
    <content type="html"><![CDATA[<p>好奇害死猫。</p>

<p>一开始是想着给现在的博客主题添加一个sidebar，再后来就想着搞清楚Octopress的原理，仔细一研究，原来里面用到了好多好玩的新技术啊（对我而言的新技术，我对网页的认识还停留在html css php等），下面就盘点下我从Octopress/Jekyll里了解到的“新”技术。</p>

<ul>
<li>Octopress是Jekyll的一个wrapper程序，Jekyll transform your plain text into static websites and blogs. Jekyll是一个静态博客编译器，负责把你写的代码编译成一个完整的博客网站。这样生成的网站属于静态网站，它是想对于wordpress这样的带数据库的动态网站而言的。很显然，静态网站的一大优点就是响应速度比动态网站相对要快，因为所有页面一旦生成就不再改变了嘛，不需要跟跟数据库交互；缺点就是每次更新都需要重新编译。</li>
<li><p>Sass &amp;&amp; Compass。这年头写CSS是用Sass和Compass了，我已经OUT了太久了。CSS不是一种编程语言，没有变量，没有条件语句，只是一行行的描述，写起来很费事，于是程序员童鞋忍不住了，Sass诞生了！Sass是一种CSS的开发工具，提供了很多便利的写法，可大大节省设计者的时间，使得CSS的开发变得简单。Compass是Sass的工具库(toolkit)，Sass本身只是一个编译器，Compass在它的基础上，封装了一系列有用的模板，使得CSS的开发更加便利！它们之间的关系，类似Javascript和jQuery、python和Django的关系。  <br/>
<strong>说到这里我可以自我鄙视下嘛？人家其实连CSS都不会。。</strong> 唉，各种标签、类一会儿就被转晕了。。</p></li>
<li><p>YAML。递归的名字是YAML Ain&rsquo;t Markup Language，官方给出的定义：YAML is a human friendly data serialization
standard for all programming languages.也就是说它是一种数据表示的标准，类似于xml，实际上是将来可能会取代xml的数据标准，YAML试图用一种比XML更敏捷的方式，来完成XML所完成的任务。我的感觉是，YAML确实比xml和jason更容易阅读，看起来结构比较清楚，容易理解一点。</p></li>
<li>Liquid。Ruby library for rendering safe templates which cannot affect the security of the server they are rendered on.所谓的templating language，模板语言。可以嵌入在web页面中来形成模板页面，后期根据不同的页面参数会编译成不同的页面，甚至还支持使用if for等类编程语句，非常灵活。Jekyll在它的模板文件中大量使用了liquid语言。</li>
<li>FontAwesome。The iconic font designed for Bootstrap.Font Awesome gives you scalable vector icons that can instantly be customized — size, color, drop shadow, and anything that can be done with the power of CSS.Font Awesome是一种出色的免费iconic font，别让字面意思误导了，这货其实不是字体，是网站上用的一些小图标，可能你都没有注意到，但也确实会给网站增色不少。看到一篇介绍iconic font的文章，<a href="http://lepture.com/work/iconic-fonts">Iconic Fonts 簡介</a>，讲的非常不错！我目前用的主题fabric的header里用的字体就是来自google font的Slackey。</li>
<li>Animate.css。animate.css is a bunch of cool, fun, and cross-browser animations for you to use in your projects. Great for emphasis, home pages, sliders, and general just-add-water-awesomeness.用纯CSS实现的动画效果集合，非常酷！ <br/>
How to use it?  <br/>
To use animate.css in your website,simply drop the stylesheet into your document&rsquo;s <code>&lt;head&gt;</code>, and add the class <code>animated</code> to an element, along with any of the animation names.That&rsquo;s it! You&rsquo;ve got a CSS animated element.Super!
关于怎么用CSS3实现动画效果，看<a href="http://www.w3schools.com/css3/css3_animations.asp">这里</a></li>
<li>google web font。顾名思义，是Google提供的网上免费字体。使用方法之一是，首先在<code>&lt;header&gt;</code>里添加对网上字体的引用，比如<code>&lt;link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Tangerine"&gt;</code>，然后就可以在CSS里指定了。</li>
<li><p>fancybox。FancyBox is a tool for displaying images, html content and multi-media in a Mac-style &ldquo;lightbox&rdquo; that floats overtop of web page. It was built using the jQuery library.</p></li>
<li><p>两个html5新标签。通过这番折腾知道了两个新标签<code>&lt;header&gt;</code>和<code>&lt;article&gt;</code></p></li>
<li>Octopress/Jekyll的layouts</li>
</ul>


<p>其实很容易理解的东西，不知为什么搞了很久才弄明白，layouts文件夹里放的是博客的模板文件，顾名思义就是一个框架，相当于人的骨骼，把具体的博客内容填进去后就成了最终的博客。通常为了不同的用途，会有多个模板文件，为了简化代码，这几个模板文件之间通常有继承关系。比如，default.html里放的是所有页面都会有的东西，比如页面开始的引用、head、footer等，post.html在default.html的基础上再做进一步的修改，思想有点类似类的继承，不过在这里只能在原有的基础上继续添加，不能覆盖原来的“方法”。</p>

<p>另外，在某个模板中还可以include进别的模板，比如在default.html中include进foot.html，这样做有利于管理代码，否则所有的代码都在一个文件里，看着混乱，也不容易管理。所有include的模板都在<code>source/_include</code>文件夹里。</p>
]]></content>
  </entry>
  
</feed>
