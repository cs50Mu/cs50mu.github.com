<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[The Hard Way Is Easier]]></title>
  <link href="http://cs50Mu.github.io/atom.xml" rel="self"/>
  <link href="http://cs50Mu.github.io/"/>
  <updated>2014-10-07T11:51:13+08:00</updated>
  <id>http://cs50Mu.github.io/</id>
  <author>
    <name><![CDATA[linuxfish]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[理解Python中的stdin stdout stderr]]></title>
    <link href="http://cs50Mu.github.io/blog/2014/10/07/io-in-python/"/>
    <updated>2014-10-07T10:29:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2014/10/07/io-in-python</id>
    <content type="html"><![CDATA[<p>看到一个题目，要求用Python实现linux中的命令tee的功能，tee的功能还是很简单的，就是把接收到的标准输入再输出到重定向和一个文件中。这些用Python来做应该不是什么难事，可是在Python里面怎么接收标准输入呢？</p>

<p>首先，有这样一个层级关系，<code>print</code>和<code>raw_input</code>这样的高级命令调用的是sys.stdin和sys.stdout，而sys.stdin和sys.stdout是file like object（类似于linux中一切设备皆文件），这一层的实现是Python的io模块。</p>

<p>下面通过两个例子可以清楚的看出print和sys.stdin和sys.stdout的关系。每个例子中第一句实现的效果跟后面的一沱实现的效果是一样一样的～</p>

<pre><code>######### stdout test ########
print 'hello world'

import sys
sys.stdout.write('hello world')

######### stdin test ########
print 'hi, %s' %raw_input('please input your name: ')

import sys
print 'please input your name: ',
name = sys.stdin.readline()[:-1]
print 'hi, %s' %name
#############################
</code></pre>

<p>比较好玩的事情是可以通过更改sys.stdin sys.stdout来实现类似linux中的重定向操作。比如默认stdout是终端，你可以在代码里通过<code>f = open(filename, 'w')</code> <code>sys.stdout = f</code>来把输出重定向到一个文件。</p>

<p>下面说下更底层的io模块。</p>

<p>像我们平时通过open等命令建立file like object后所使用的所有命令都是在io模块里实现的，比如write read readline seek flush等等。</p>

<p>io分三种类型：text I/O、binary I/O、raw I/O，以前总是傻傻分不清楚，现在终于理解了～</p>

<p>text I/O顾名思义，就是对我们人类来说能看到的、能识别的文字数据。无论什么数据都是以二进制的形式存储在计算机里的，但人类能识别的文字是以编码（assic、gbk、utf8）的形式存储在计算机里的，因为最终还要拿出来给人类读啊～～</p>

<p>binary I/O就是指所有非文本信息了，这类数据无需编码解码，也不用处理换行符，比如图片文件等。这个类型对应的open里的打开模式<code>'b'</code></p>

<p>raw I/O文档里说不常用，目前我也没理解它是干啥用的。。</p>

<p>最后，简陋的tee</p>

<pre><code>import sys 

def tee(filename):
    with open(filename, 'w') as f:
    for line in sys.stdin.readlines():
        sys.stdout.write(line)
        f.write(line)

if __name__ == '__main__':
    filename = sys.argv[1]
    tee(filename)
</code></pre>

<h3>参考</h3>

<ul>
<li><a href="http://en.wikibooks.org/wiki/Python_Programming/Input_and_Output">Python Programming/Input and Output</a></li>
<li><a href="http://woodpecker.org.cn/diveintopython/scripts_and_streams/stdin_stdout_stderr.html">标准输入、输出和错误</a></li>
<li><a href="https://docs.python.org/3.1/library/io.html#module-io">io — Core tools for working with streams</a></li>
<li><a href="http://5ydycm.blog.51cto.com/115934/304324">Python之sys模块小探</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[preparing for the job]]></title>
    <link href="http://cs50Mu.github.io/blog/2014/10/06/preparing-for-the-job/"/>
    <updated>2014-10-06T10:16:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2014/10/06/preparing-for-the-job</id>
    <content type="html"><![CDATA[<p>面试太渣，皆因毫无准备。</p>

<h3>多进程与多线程的区别</h3>

<ul>
<li>进程叫process，线程叫thread，cpu在任一时刻只能运行一个进程。一个进程可以包含多个线程</li>
<li>进程开销较大，线程开销较小</li>
<li>进程是<strong>资源分配</strong>的基本单位，线程是cpu调度的基本单位</li>
<li>进程有自己的地址空间，系统必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，是一种非常昂贵的多任务工作方式。而一个进程中的线程，它们之间共享大部分数据，使用相同的地址空间，因此切换线程比切换进程快的多，也就是说线程之间的通信比较方便，但从另一方面来说，如何控制线程对共享数据的访问又是一个难点了。</li>
<li>多进程程序比多线程程序要健壮。一个进程挂了，对别的进程基本不会有影响，但一个线程挂了，很可能会导致进程内的其它线程也挂掉。</li>
</ul>


<p>参考：
<a href="http://blog.csdn.net/morewindows/article/details/7392749">秒杀多线程第一篇 多线程笔试面试题汇总</a></p>

<h3>Python如何进行内存管理？</h3>

<ul>
<li>在一个对象的引用计数减为0时，对此对象进行内存回收</li>
</ul>


<p>参考：
<a href="http://www.cnblogs.com/vamei/p/3232088.html">Python深入06 Python的内存管理</a></p>

<h3>Python里如何拷贝一个对象？</h3>

<ul>
<li>首先要知道为什么要复制对象，因为在Python中无论是把对象作为参数传递还是作为函数返回值，都是引用传递的。那当我们不想传递引用的时候就要复制一个全新的对象了。</li>
<li>复制分为浅复制和深复制。浅复制是指只复制对象，但对象里的元素仍然使用引用。深复制（deepcopy）就是完完全全的复制了。</li>
</ul>


<p>参考：
<a href="http://blog.csdn.net/sharkw/article/details/1934090">深复制和浅复制</a></p>

<h3>RE模块中search和match的区别</h3>

<ul>
<li>match只搜寻第一个是否满足，若满足返回它，若不满足，则返回None</li>
<li>search搜索字符串，返回它遇到的第一个满足条件的，而不仅仅是查看第一个
注意这两个命令都是只返回一个满足条件的，要想返回所有满足条件的，要用findall</li>
</ul>


<p>参考：
<a href="https://docs.python.org/2/library/re.html#search-vs-match">search vs match</a></p>

<h3>用Python匹配HTML tag的时候，<code>&lt;.*&gt;</code>和<code>&lt;.*?&gt;</code>有什么区别？</h3>

<p>贪婪模式和非贪婪模式。
The <code>'*'</code>, <code>'+'</code>, and <code>'?'</code> qualifiers are all greedy; they match as much text as possible. Sometimes this behaviour isn’t desired; if the RE <code>&lt;.*&gt;</code> is matched against <code>'&lt;H1&gt;title&lt;/H1&gt;'</code>, it will match the entire string, and not just <code>'&lt;H1&gt;'</code>. Adding <code>'?'</code> after the qualifier makes it perform the match in non-greedy or minimal fashion; as few characters as possible will be matched. Using <code>.*?</code> in the previous expression will match only <code>'&lt;H1&gt;'</code>.</p>

<h3>python程序中文输出问题怎么解决？</h3>

<p>中文输出的问题都是由于编码问题。</p>

<p>中文字符串使用的编码与其所在的文件使用的编码一致。所以正确处理的步骤是：先用其原有编码decode成python内部的unicode，做了该做的处理后，什么时候想输出啦，这时候再使用encode，把它encode成任何想输出的编码形式。</p>

<h3>正则表达式匹配ip</h3>

<p><code>src = "security/afafsff/?ip=123.4.56.78&amp;id=45"</code>，请写一段代码用正则匹配出ip</p>

<pre><code>regx = re.compile(r'([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)')
m = regx.search("security/afafsff/?ip=123.4.56.78&amp;id=45")
m.groups()
('123', '4', '56', '78')
</code></pre>

<p>注意，使用groups可以返回找到的所有subgroups，非常方便。另外，group(0)返回整个匹配，group(1)返回第一个subgroup等等</p>

<h3>json</h3>

<p>写一段代码用json数据的处理方式获取{&ldquo;persons&rdquo;:[{&ldquo;name&rdquo;:&ldquo;yu&rdquo;,&ldquo;age&rdquo;:&ldquo;23&rdquo;},{&ldquo;name&rdquo;:&ldquo;zhang&rdquo;,&ldquo;age&rdquo;:&ldquo;34&rdquo;}]}这一段json中第一个人的名字。</p>

<pre><code>j = json.loads('{"persons":[{"name":"yu","age":"23"},{"name":"zhang","age":"34"}]}')
j.get('persons')[0]['name']
</code></pre>

<h3>平衡点</h3>

<p>比如int[] numbers = {1,3,5,7,8,25,4,20}; 25前面的总和为24，25后面的总和也是24，25这个点就是平衡点；假如一个数组中的元素，其前面的部分等于后面的部分，那么这个点的位序就是平衡点
我写出的版本，完全就是把题意翻译了一遍，能满足要求，效率应该不好</p>

<pre><code>def findMiddle(lst):
    for i in xrange(1, len(lst)-1):
    if sum(lst[:i]) == sum(lst[i+1:]):
        print i
</code></pre>

<p>看到别人的做法是，先算一遍总和，然后从左往右一个一个加，出现和一半的时候，说明找到平衡点了。</p>

<pre><code>def findMiddle2(lst):
    totle = sum(lst)

    add = 0 
    for i in xrange(0, len(lst)-1):
    add += lst[i]
    if totle - lst[i+1] == 2 * add:
        print i+1, lst[i+1]
</code></pre>

<h3>支配点</h3>

<p>支配数：数组中某个元素出现的次数大于数组总数的一半时就成为支配数，其所在位序成为支配点；比如int[] a = {3,3,1,2,3};3为支配数，0，1，4分别为支配点；</p>

<pre><code>def findDomain(lst):
    count = [ i for i,x in enumerate(lst) if lst.count(x) &gt; len(lst)//2 ]  # elegant solution
    if count:
    print lst[count[0]], count
</code></pre>

<h3>什么是PEP 8？</h3>

<p>Python编码规范</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[socks代理和http代理的区别]]></title>
    <link href="http://cs50Mu.github.io/blog/2014/10/05/socks-proxy-and-http-proxy/"/>
    <updated>2014-10-05T11:50:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2014/10/05/socks-proxy-and-http-proxy</id>
    <content type="html"><![CDATA[<p>一直傻傻分不清楚，都是因为平时很少接触，虽然翻墙常用，但也只是按教程一步一步来，并未知其所以然。</p>

<p>之前一直听别人说socks代理多么多么好，自己只是模模糊糊半懂不懂，现在终于切身体会到了一个好处，用socks代理后就没有证书问题的困扰了～～之前用的GoAgent使用的是http代理，每次访问https网站时，总是提示证书有问题，导入GoAgent的自带证书还是有问题，这下用了shadowsocks后一切都清净了。。为什么socks代理就这么牛逼呢？因为socks代理更底层，只负责发送接收数据，至于你是什么http ftp tcp udp它根本就不care。</p>

<ul>
<li>socks代理更底层，是在会话层；而http代理是在应用层。因此socks代理可以代理一切客户端的连接，而http代理只能代理使用http协议的客户端</li>
<li>由于更底层，不需要处理高级协议的细节，所以socks代理更快</li>
<li>socks协议分v4和v5版本，v4只能代理tcp协议，而v5什么协议都可以代理</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[binary search and spreadsheet numeration]]></title>
    <link href="http://cs50Mu.github.io/blog/2014/09/18/binary-search-and-spreadsheet-numeration/"/>
    <updated>2014-09-18T18:54:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2014/09/18/binary-search-and-spreadsheet-numeration</id>
    <content type="html"><![CDATA[<p>昨天去知道创宇的面试失败了，很感谢他们能给我这个机会。通过这次面试，我总算迈出了一步，更加明确了自己应该努力的方向。这次面试反映出的一个很严重的问题就是，手太生，学了这么长时间Python，竟然连一些常用的用法，命令都得现查文档。自己反思一下，没有自己动手写多少代码，这个是问题的关键。</p>

<p>面试我的雨哥人非常nice，面对我这么菜的表现没有一点不耐烦，他说的一句话让我印象深刻，“既然是有兴趣，平时就多花点时间，对得起兴趣这两个字”。我会的。</p>

<h2>二分法查找</h2>

<p>我想这个应该是最容易理解的算法了吧，我差点就在面试的时候完成了，well,almost&hellip;</p>

<p>思路很简单，因为给出的列表已经是排好顺序的了，因此直接找到中间的一个记为mid，若是要找的元素，任务完成。若mid比要找的元素大，好的，那么要找的元素肯定在start跟mid之间了，若mid比要找的元素小，那么要找的元素肯定在mid和end之间了。</p>

<pre><code>def binarySearch(lst, element, start, end):
    mid = (start + end)/2 
    if element == lst[mid]:
    print 'Found, %d' % mid 
    elif mid == start:
    if element == lst[mid+1]:  # 主要处理两个相邻的数的情况，这种情形下mid必然等于start
        print 'Found, %d' % (mid+1) # 因此如果end（也就是mid+1）不等于element的话，则没找到
    else:
        print 'Not found'
    elif element &gt; lst[mid]:
    return binarySearch(lst, element, mid, end)
    elif element &lt; lst[mid]:
    return binarySearch(lst, element, start, mid)

def binarySearch2(lst, element, start, end):
    mid = (start + end)/2
    if element == lst[mid]:
    return 'Found, %d' % mid 
    elif start &gt; end:
    return 'Not found'
    elif element &lt; lst[mid]:
    return binarySearch2(lst, element, start, mid-1)
    elif element &gt; lst[mid]:
    return binarySearch2(lst, element, mid+1, end)

def binarySearch3(lst, element):
    start = 0 
    end = len(lst) - 1
    while (start &lt;= end):
    mid = (start + end)/2
    if lst[mid] == element:
        return 'Found', mid
    elif lst[mid] &gt; element:
        end = mid - 1
    elif lst[mid] &lt; element:
        start = mid + 1
    return 'Not found'
</code></pre>

<p>上面的方法一是我自己瞎想的ugly思路，方法三是我在一站式C编程上看到的，方法二是我根据方法三的思路用递归改写的</p>

<h2>spreadsheet numeration</h2>

<p>这个题目其实我之前在CodeForces上做过的，可惜没有理解它的真谛，虽然当时误打误撞做出来了，还是没有效果，现在遇到还是不会做，面试中雨哥一句话点醒我，“进制转换”，是啊，这个问题实质上就是十进制转换26进制的问题。那进制转换无非就是要做除法、取余。但是也不是这么简单，有一个比较tricky的问题，就是在转换26的倍数的时候，需要做一些特殊处理才行。</p>

<pre><code>def numTochar(num):
    result = ''
    ori = num 
    while num:
    mod = num % 26
    if mod == 0:
        mod = 26
        num = num/26 - 1 # special cases for 'Z' 
    else:
        num /= 26
    result = chr(mod + ord('A') - 1) + result
    return result,ori

def numTochar2(num):
    result = ''
    ori = num 
    while num:
    mod = num % 26
    if mod == 0:
        mod = 26
    num -= 1       # a more elegant solution
    num /= 26
    result = chr(mod + ord('A') - 1) + result
    return result,ori
</code></pre>

<p>方法一是我自己捣鼓的，方法二是我在CodeForces上看到了，效果应该是一样的，都是为了在转换26的倍数的时候能够得出正确的结果，做出的一点特殊处理，不过显然后者更加优雅，每个数在除26之前先减1,这样既对于非26倍数的数没有影响，又能巧妙的处理26的倍数时的特殊情况。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Structure and Interpretation of Computer Programs]]></title>
    <link href="http://cs50Mu.github.io/blog/2014/07/26/sicp/"/>
    <updated>2014-07-26T22:59:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2014/07/26/sicp</id>
    <content type="html"><![CDATA[<p>大名鼎鼎的SICP，下面是我在学习Berkeley的CS61A时做的笔记,非常有意思的一门课！</p>

<h2>高阶函数</h2>

<p>理解这玩意儿有时候确实挺费脑筋。。。下面这个trick花了好久才理解。。关键一开始没想明白返回的到底是匿名函数还是匿名函数的执行结果</p>

<pre><code>def cons(a, b):
    return lambda m: m(a,b) # 此处返回的是一个参数为m的匿名函数！！并且m是一个函数，m接受两个参数a和b

def car(p):
    return p(lambda x,y:x) # 

car(cons(1,2)) # 结果应该为1
</code></pre>

<p>以上代码大概类似于下面的代码：</p>

<pre><code>def fuck(func):
    def wrapper(a,b):
        return func(a,b)
    return wrapper

x = fuck(lambda x,y:x)
x(1,2) # 输出1
</code></pre>

<h2>递归  破钱</h2>

<p>下面的函数实现的功能是，给定一个数值，比方说100块，和一堆小面额的纸币，找出用这些小面额纸币来表示这100块总共有几种方法。其中link函数是用来制作链表的，first函数返回链表的第一个元素，rest函数返回链表的剩余所有元素。可以看到函数是用递归实现的，依据大概是这样的：100块的表示方法可以分为两类，一类方法中使用链表中的第一个面额，另一类方法中不使用第一个面额。就这么简单。。。神奇的是它竟然是能工作的！</p>

<pre><code>def count_change(amount, denominations):
    '''
    Return the number of ways to make change for amount
    '''
    if amount &lt; 0 or denominations == empty:
        return 0
    elif amount == 0:
        return 1
    using_coin = count_change(amount - first(denominations), denominations)
    not_using_coin = count_change(amount, rest(denominations))
    return using_coin + not_using_coin

denominations = link(50, link(25, link(10, link(5, link(1, empty)))))
&gt;&gt;&gt; print_linked_list(denominations)
&lt; 50 25 10 5 1 &gt;
&gt;&gt;&gt; count_change(100, denominations)
292
</code></pre>

<h2>ADT(Abstract Data type)</h2>

<p>ADT也属于抽象的一种，目的是控制复杂度，把复杂并且与下面要实现的功能无关的细节隐藏起来，只把几个关键的东西暴露给外部，要形成一个ADT一般需要一个constructor，一个selector，一个mutator等，有了这些，外部就可以用它们进一步实现别的功能了，像链表啊，树啊都属于ADT。其中，deep list和tree属于hierarchical data structure</p>

<h2>Implicit Sequences</h2>

<p>a sequence can be represented <strong>without</strong> each element being stored explicitly in the memory of the computer. That is, we can construct an object that provides access to all of the elements of some sequential dataset without computing all of those elements in advance and storing them. Instead, we compute elements on demand. 很巧妙的一种实现方式，不是把元素全部计算出来放在内存里等着去取，而是需要的时候才计算一个出来，这样可以节省大量的内存。这在计算机科学中叫lazy computation(lazy computation describes any program that delays the computation of a value until that value is needed). 但注意，实现这个强大功能的前提是sequential access(相对于random access)，也就是说只能按顺序依次获取，不能想取哪个就取哪个。嗯，iterator就是在这个背景下诞生了。。An iterator is an object that provides <strong>sequential access</strong> to an underlying sequential dataset. iterator就是为了方便处理那些具有内在顺序结构的数据而诞生的。The iterator abstraction has two components: a mechanism for retrieving the next element in some underlying series of elements and a mechanism for signaling that the end of the series has been reached and no further elements remain. In programming languages with built-in object systems, this abstraction typically corresponds to a particular interface that can be implemented by classes.</p>

<ul>
<li>iterators与iterables</li>
</ul>


<p>原来这两个不是一个东西。iterators需要实现<code>__next__</code>方法，是具体干活的。   <br/>
An object is iterable if it <strong>returns an iterator</strong> when its <code>__iter__</code> method is invoked. Iterable values represent data collections, and they provide a fixed representation that may produce more than one iterator. iterator和iterable类似于类和实例的关系吧,iterator负责实现模型、架构，iterable负责实例化。For example, an instance of the <code>Letters</code> class below represents a sequence of consecutive letters. Each time its <code>__iter__</code> method is invoked, a new <code>LetterIter</code> instance is constructed, which allows for sequential access to the contents of the sequence.</p>

<pre><code>&gt;&gt;&gt; class LetterIter:
    """An iterator over letters of the alphabet in ASCII order."""
    def __init__(self, start='a', end='e'):
        self.next_letter = start
        self.end = end
    def __next__(self):
        if self.next_letter == self.end:
        raise StopIteration
        letter = self.next_letter
        self.next_letter = chr(ord(letter)+1)
        return letter

&gt;&gt;&gt; class Letters:
    def __init__(self, start='a', end='e'):
        self.start = start
        self.end = end
    def __iter__(self):
        return LetterIter(self.start, self.end)

&gt;&gt;&gt; b_to_k = Letters('b', 'k')
&gt;&gt;&gt; first_iterator = b_to_k.__iter__()
&gt;&gt;&gt; next(first_iterator)
'b'
&gt;&gt;&gt; next(first_iterator)
'c'
&gt;&gt;&gt; second_iterator = iter(b_to_k)
&gt;&gt;&gt; second_iterator.__next__()
'b'
&gt;&gt;&gt; first_iterator.__next__()
'd'
&gt;&gt;&gt; first_iterator.__next__()
'e'
&gt;&gt;&gt; second_iterator.__next__()
'c'
&gt;&gt;&gt; second_iterator.__next__()
'd'
</code></pre>

<p>但是！在Python中<code>__next__</code>和<code>__iter__</code>方法是在同一个类中的！To use an iterator in a for loop, the iterator must also have an <code>__iter__</code> method. The <a href="http://docs.python.org/3/library/stdtypes.html#iterator-types">Iterator types</a> section of the Python docs suggest that an iterator have an <code>__iter__</code> method that returns the iterator itself, so that all iterators are iterable. 只要理解了<code>__iter__</code>方法的作用，也很容易理解的啦。</p>

<ul>
<li>Generators and Yield Statements</li>
</ul>


<p>Generators属于Iterator，a generator is an <strong>iterator</strong> returned by a special class of function called a generator function. Generator functions are distinguished from regular functions in that rather than containing return statements in their body, they use yield statement to return elements of a series.</p>

<p>The Letters and Positives objects above require us to introduce a new field self.current into our object to keep track of progress through the sequence. With simple sequences like those shown above, this can be done easily. With complex sequences, however, it can be quite difficult for the <code>__next__</code> method to save its place in the calculation. Generators allow us to define more complicated iterations by leveraging the features of the Python interpreter.</p>

<p>Generators do not use attributes of an object to track their progress through a series. Instead, they control the execution of the generator function, which runs until the next yield statement is executed each time the generator&rsquo;s <code>__next__</code> method is invoked. The Letters iterator can be implemented much more compactly using a generator function. 虽然实现的功能是一样的，但Generators与iterators的实现机理是不一样的，yield的机理貌似是coroutines，到底是个神马东东，待查。</p>

<pre><code>&gt;&gt;&gt; def letters_generator():
    current = 'a'
    while current &lt;= 'd':
        yield current
        current = chr(ord(current)+1)

&gt;&gt;&gt; for letter in letters_generator():
    print(letter)
a
b
c
d
</code></pre>

<p>Even though we never explicitly defined <code>__iter__</code> or <code>__next__</code> methods, the yield statement indicates that we are defining a generator function. When called, a generator function doesn&rsquo;t return a particular yielded value, but instead a generator (which is a type of iterator) that itself can return the yielded values. A generator object has <code>__iter__</code> and <code>__next__</code> methods, and each call to <code>__next__</code> continues execution of the generator function from wherever it left off previously until another yield statement is executed.</p>

<p>The first time <code>__next__</code> is called, the program executes statements from the body of the <code>letters_generator</code> function until it encounters the yield statement. Then, it pauses and returns the value of current. yield statements do not destroy the newly created environment, they preserve it for later. When <code>__next__</code> is called again, execution resumes where it left off. The values of current and of any other bound names in the scope of <code>letters_generator</code> are preserved across subsequent calls to <code>__next__</code>.</p>

<p>这样，可以用yield语句来简化iterables的写法</p>

<pre><code>&gt;&gt;&gt; class LettersWithYield:
    def __init__(self, start='a', end='e'):
        self.start = start
        self.end = end
    def __iter__(self):
        next_letter = self.start
        while next_letter &lt; self.end:
        yield next_letter
        next_letter = chr(ord(next_letter)+1)
</code></pre>

<p>以前没有Generators的时候，还需要定义一个<code>__next__</code>方法来生成iterator，然后用<code>__iter__</code>方法来返回self，这下因为yield本身返回的就是一个Generator(也属于Iterator)，所以无需<code>__next__</code>方法来生成iterator。</p>

<h2>Mutation in for loops</h2>

<p>如果在for循环中对对象做了修改（增加或删除），会出现无法预测的结果</p>

<pre><code># Demo: Mutation in For Loops
# lst = list(range(10, 20))
# for item in lst:
#     print(item)
#     lst.remove(item)
# lst
# 下面是解决办法, 不过原理未搞懂，待查
class BetterList(list):
    def __iter__(self):
    return list.__iter__(self[:])
</code></pre>

<h2>nonlocal与list</h2>

<p>看下面两段代码</p>

<pre><code>def make_accumulator():
    """Return an accumulator function that takes a single numeric argument and
    accumulates that argument into total, then returns total.
    """
    total = []
    def accumulator(amount):
    total.append(amount)
    return sum(total)
    return accumulator

def make_accumulator_nonlocal():
    """Return an accumulator function that takes a single numeric argument and
    accumulates that argument into total, then returns total.
    """
    total = 0
    def accumulator(amount):
    nonlocal total
    total += amount
    return total
    return accumulator
</code></pre>

<p>为何单个变量(total)在&#8221;全局&#8221;访问的时候需要nonlocal参数，而列表就不用了呢？</p>

<h2>format method of strings</h2>

<pre><code>&gt;&gt;&gt; 'I {0}, you {0}, we all {0} for {1}!'.format('scream', 'ice cream')
'I scream, you scream, we all scream for ice cream!'
</code></pre>

<h2>Generic Functions</h2>

<p>Generic functions are methods or functions that apply to arguments of different types. 我理解就是不管对象类型是不是一样，都可以用这个通用函数来做运算。Generic functions主要有下面三种实现方式：
&ndash; Interfaces
&ndash; Type dispatching
&ndash; Coercion</p>

<h2>Memoization</h2>

<p>Keep track of all the calls we have ever made to fib and their answers. Then when we made a repeated recursive call, we immediately return the answer.</p>

<h2>Huffman Encoding</h2>

<p>一种可变编码方式，可针对词频进行优化编码，出现次数多的字母用相对小的位数来编码，出现次数多的字母用相对多的位数来编码，这样相对于固定位编码方式可节省存储空间。  <br/>
使用方法：</p>

<ul>
<li>统计字母出现频率，并据此创建霍夫曼二叉树。创建的方法就是对给定的字母、频率，不停的merge掉频率最小的两个，并根据这两个生成一个新的HuffmanTree，它的频率为那两个频率最小的频率之和，以此直至只剩下两个HuffmanTree为止.</li>
<li>编码</li>
<li>解码
编码和解码部分可用递归优雅的实现

<h2>Scheme</h2></li>
<li>区分symbol和string. When you type things in the interpreter, Scheme will evaluate it. The rule for evaluating a symbol is to get the value bound to that symbol. This is one difference between strings and symbols&mdash;symbols don&rsquo;t evaluate to themselves(which strings do). However, as you saw above, when you type in &lsquo;a, you get a. This is because when you use single quote, you&rsquo;re telling Scheme <strong>not to follow</strong> the normal rules of the evaluation and just have the symbol return as itself.</li>
<li>Special Forms. 类似于其它语言中的关键字，比如define if and or等等</li>
<li>Lambdas. 语法： <code>(lambda (&lt;PARAMETERS&gt;) &lt;EXPR&gt;)</code></li>
<li>Functions. 语法：<code>(define (&lt;FUNCTIONNAME&gt; &lt;PARAMETERS&gt;) &lt;EXPR&gt;)</code>. Python will automatically transform it to <code>(define &lt;FUNCTIONNAME&gt; (lambda (&lt;PARAMETERS&gt;) &lt;EXPR&gt;)</code> for you.所以在Scheme中，lambda更基础.</li>
<li>关键字let. 语法：
  (let ( (<SYMBOL1> <EXPR1>)
      &hellip;
      (<SYMBOLN> <EXPRN>) )
      <BODY> )
它等价于：<code>( (lambda (&lt;SYMBOL1&gt; ... &lt;SYMBOLN&gt;) &lt;BODY&gt;) &lt;EXPR1&gt; ... &lt;EXPRN&gt;)</code></li>
<li>Pairs. 创建：<code>(define a (cons 1 2))</code> 获取： <code>(car a)</code> <code>(cdr a)</code></li>
<li>List. A List is a specific kind of Pair that is either nil(an empty list) or a Pair whose cdr is another List. 比如，(cons 1 (cons 2 nil))，它可以简写成&#8217;(1 2)，检查List是否为空可用null?语句</li>
</ul>


<h2>Tail Recursion 尾递归</h2>

<p>是对递归的一种优化，我们都知道，一般线性递归在新的调用之前需要在堆栈中保存当前调用的信息，这样随着函数调用的增多，对内存的占用会越来越大，而尾递归能够实现这一次的调用使用的堆栈空间直接覆盖上次用过的，因此虽然函数调用在不断进行，但对内存的占用却是不变的！（linuxfish注：看了一堆介绍，我肿么觉得尾递归有点过程语言中循环的感觉，是不是因为函数式编程中没有循环，才用尾递归的？）</p>

<p>注意，要区分尾递归语法和尾递归优化，也就是说，你可以把递归写成尾递归的形式，但底层（解释器、编译器）是否给你优化就不一定了。比如，Python可以写成尾递归的形式，但是没用，照样会stackoverflow，因为解释器并不支持。</p>

<h2>Streams</h2>

<p>这应该是Python中generator的鼻祖了吧。Streams are a clever idea that allows one to use sequence manipulations without incurring the costs of manipulating sequences as list. With streams we can achieve the best of both worlds: We can formulate programs elegantly as sequences manipulations, while attaining the efficiency of <strong>incremental computation</strong>. The basic idea is to arrange to construct a stream only partially, and to pass the partial construction to the program that consumes the stream. If the consumer attempts to access a part of the stream that has not yet been constructed, the stream will automatically construct just enough more of itself to produce the required part, thus preserving the illusion that the entire stream exists. In other words. In other words, although we will write programs as if we were processing complete sequences, we design our stream implemention to automatically and transparently interleave the construction of the stream with its use.感觉这玩意儿纯粹是Schemer们妄图所有问题都用list pair来解决，发现不行后又整出来的一个东东。这也是所谓的函数式语言的懒惰特性，所谓懒就是不到万不得已不动弹。。而不是傻乎乎的一下子就把整个list都计算出来。</p>

<h2>Declarative Programming</h2>

<p>比如SQL语言</p>

<p>data values are often stored in large repositories called databases. A database consists of a data store containing structured data values and an interface for retrieving subsets of the data based on their characteristics. Each value stored in a database is called a record. Records are typically retrieved via a query, which is an expression in a query programming language. By far the most ubiquitous query language in use is called Structure Query Language or SQL.</p>

<p>SQL is an example of a declarative programming language. Expressions do not <strong>describe computations directly</strong>, but instead state the form of the <strong>result</strong> of some computation. It is the role of the <strong>query interpreter</strong> of the database system to design and perform a computational process to produce such a result.</p>

<p>This interaction differs substantially from the procedural programming paradigm of Python or Scheme. In Python, <strong>computational processes are described directly by the programmer.</strong> A declarative language specifies the form of the result, but abstracts away procedural details.</p>

<h2>Concurrency 并行</h2>

<ul>
<li>并行是一个现实问题，生活中经常会遇到，又是一个提升效率的好办法，并行办事比串行等待效率要高很多！</li>
<li>由于线程并行所导致的问题可以通过引入锁的机制来解决，不过要注意防止死锁现象。</li>
<li>还可以通过Message Passing来解决</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[捣鼓VPS翻墙]]></title>
    <link href="http://cs50Mu.github.io/blog/2014/07/14/my-first-vps/"/>
    <updated>2014-07-14T22:19:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2014/07/14/my-first-vps</id>
    <content type="html"><![CDATA[<p>在学校论坛上看到有人介绍在vps上搭建shadowsocks服务器来翻墙，看到他推荐的vps很便宜，一年才20多，于是立马也想买一个了，其实以前就想折腾vps的，无奈找到的vps价格都太高，一个月要几百块神马的，像我这么小气的人肿么可能舍得。。不过，这个实在是太便宜了啊，虽然配置是最低的了，72M内存，2G硬盘，但一个月有100G的流量，对于翻墙来说够用了，果断注册下单购买，只支持PayPal支付，于是又注册PayPal，在这上面折腾了很久，一开始注册成中国版的了，结果提示无法跨境支付，放狗搜索后发现，需要注册国际版的，以为还要审核神马的，结果直接绑定银行卡后就可以支付了，很方便啊！</p>

<p>可是才用一天就被墙了！！我目前使用的是长城宽带的服务，ssh都无法登陆了，但后来发现使用学校自己的外网还是可以用的，学校的外网应该是用的联通的服务，后来我到V2EX上问了下发现有人用长城宽带的服务也有类似的问题，该死的长城宽带！</p>

<h2>更新（20141002）</h2>

<p>不久前听人说Bandwagon出加州机房了，一直懒得弄，今天花时间看了下，果然有加州机房了，果断迁移过去，给换了个新ip，然后shadowsocks不能用了，一开始以为是shadowsocks服务器端没开，后来发现是服务器端的设置里ip也需要更新下才行。</p>

<p>正好记录下shadowsocks服务器端的配置，省得下次再忘。</p>

<ul>
<li>shadowsocks在服务器端是以daemon形式运行的。daemon脚本在<code>/etc/init.d/shadowsocks</code>，配置文件在<code>/etc/shadowsocks/config.json</code></li>
<li>要启动/关闭/重启shadowsocks，只需在命令行执行<code>/etc/init.d/shadowsocks start/stop/restart</code>，它默认开始是自启动的。</li>
<li>刚刚才知道，原来shadowsocks是socks代理，因此可以无压力访问https网站，再也不会遇到GoAgent一样的证书问题了～～哈哈，真好</li>
</ul>


<p>对了，火狐代理插件换成foxyproxy了，autoproxy已经好久不更新，基本无法使用了，之前一直迟疑不想换是因为听说foxyproxy配置比较麻烦，今天试了试才发现对于经常折腾的人来说根本就不是事～～ foxyproxy也支持订阅gfwlist列表，于是生活又美好起来了～～</p>

<h2>参考</h2>

<ul>
<li><a href="https://github.com/madeye/shadowsocks-libev">shadowsocks-libev</a></li>
<li><a href="http://www.lucong.com.cn/lulu/centos-debian-shadowsocks-libev.html">CentOS、Debian下搭建shadowsocks-libev服务端</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[冒泡排序和插入排序]]></title>
    <link href="http://cs50Mu.github.io/blog/2014/03/30/two-sort-algorithms/"/>
    <updated>2014-03-30T20:07:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2014/03/30/two-sort-algorithms</id>
    <content type="html"><![CDATA[<h2>冒泡排序</h2>

<p>应该是最简单的吧，但是效率很低。对于给定的n个无序数列，不断的比较相邻的两个数的大小，若满足条件，则互换两个数的位置，这样经过一次循环后，最大的（或者最小的）数就冒出来了，经过n次循环，顺序就排好了。具体伪代码如下：</p>

<pre><code>    for(i=0; i &lt; n; i++) {
            for(j = 0; j &lt; n - i - 1; j++) {
                    if(target[j] &gt; target[j+1]) {
                            temp = target[j+1];
                            target[j+1] = target[j];
                            target[j] = temp;
                    }   
            }   
    }   
</code></pre>

<h2>插入排序</h2>

<p>模仿的是打牌的时候，插牌的方法。对于给定的n个无序数列，从第二个数开始往下循环到第n个数，在处理某个数的时候，依次比较这个数跟它之前的数的大小，直到找到合适的位置后就插入。具体伪代码如下：</p>

<pre><code>    for(i = 1; i &lt; n; i++) {
            key = target[i];  // 待插的值
            for(j = i - 1; (j &gt;= 0) &amp;&amp; (target[j] &gt; key); j--) {
                    target[j+1] = target[j];   // 移位，给要插入的数让位
            }
            target[j+1] = key;    // 插进去
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重新学习C]]></title>
    <link href="http://cs50Mu.github.io/blog/2014/03/28/relearning-c/"/>
    <updated>2014-03-28T20:14:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2014/03/28/relearning-c</id>
    <content type="html"><![CDATA[<p>发现写learn python the hard way的大神Zed.A.Shaw的the hard其实是一个系列，除了python还有Ruby、C、SQL、Regex，都是我想学的有木有！这几天在看他的C的教程，虽然只是一个alpha版本，但已经很牛逼了啊，一开始还可以，现在光是消化一小节都要好几天好不好！看了他的教程，感觉自己以前学过的那点东西真的是连屎都不如。。anyway，学到了很多东东，记录下学到的东西。</p>

<ul>
<li>指针。发现在实际使用中很容易把指针变量和指针所指的内容搞混，要记住，指针变量里存放的只是一个地址而已，所以它的大小（位数）是固定的，应该是4个字节，跟它所指的内容没有一点关系。比如我在练习中遇到的一个问题是，有一个结构体，结构体有几个字符型指针，也就是说这几个指针是指向几个字符串的，然后在给这个结构体申请空间的时候我就晕了。。到底应该申请多少呢？直接malloc(sizeof(struct Address))吗？因为我总纠结着结构体里的字符型指针，想着这几个指针指向的字符数目又没有定，这可怎么办呢？其实是我想多了，把指针和它指向的内容混淆了，要知道，指针就是指针而已，大小固定，4个字节，所以上面那个结构体的大小是固定的，可以直接用sizeof来计算。至于那几个指针指向的字符串嘛，等要用的时候再malloc就可以了，也就是说它们跟上面说的结构体没半毛钱关系！只是因为里面有个指针指向了它们而已。</li>
<li>内存管理。这个之前真的是没有想过，也没有遇到过。因为总是在用一些脚本语言，根本就没有关注过内存管理的问题，导致现在遇到都不知道该怎么处理了，现在通过一次练习，对内存管理有了一些理解了。基本上，在C中一切内存管理都要自己来，要放东西的时候就要自己malloc申请空间，不需要提前申请，只要在需要使用的时候申请就行了，然后记得申请的空间用完后要自己释放，否则会导致内存泄露！</li>
<li>动态数据结构从文件的读取和写入。乍一想觉得挺简单，其实还是蛮复杂的好不好。。先说写入，这里说的动态结构是指用指针实现的，就是不是固定的数组，所以具体大小可以到时候malloc随意申请，灵活是灵活，但要写入文件的时候就SB了，不能像固定结构那样直接一个<code>fwrite(&amp;addr, sizeof(struct Addr), 1, fpr)</code>就行了好不好，你要自己找到指针指向的内容，然后一个一个自己写啊！再说读取，首先顺序要一致，怎么写入的就要怎么读取出来，否则肯定是没戏啊，然后读取的时候要先准备好地方啊！也就是说要为读入的数据用malloc提前申请空间啊！还有一个就是一次读入数据大小的问题，这个要好好弄清楚，我在练习的时候就是这个没弄清楚，导致程序一直都有问题，还是那句话，不要把指针和指针指向的内容混淆！！</li>
<li>gdb。gdb是个神器！！</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[统计浏览器历史记录]]></title>
    <link href="http://cs50Mu.github.io/blog/2014/03/03/get-your-visit-internet-frequency-by-python/"/>
    <updated>2014-03-03T19:13:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2014/03/03/get-your-visit-internet-frequency-by-python</id>
    <content type="html"><![CDATA[<p>又是好久没更新。</p>

<p>知乎是个好网站。那么多大牛分享自己的经验教训～涉及范围包罗万象，无所不有。对我而言，很重要的一点是它拓展了我的眼界，让我知道，哦，原来还可以这么想，事情还可以这么做，这世界上原来还有这样一种活法。。</p>

<p>逛知乎的时候还是不由自主的看起编程方面的提问了，其中有一个问题是“用python可以做哪些有趣的事？”看到大家各种有趣的分享，我想这真是太酷了！一直以来，虽然对编程很感兴趣，但总是深入不进去，刚刚有点想法的时候，可总是考虑的太复杂，牵扯的知识点太多，然后要看很多东西，最后热情就这么一点点被消磨掉了，然后就是扔下好久不去想它，直到某天忽然又有热情了，如此循环往复。。看似做了很多，其实却一直在原地踏步。看了这么多知乎牛人的回答后，有了一点点启发，也有了具体的指导，那么就按各位大牛的做法来试试，从自己感兴趣的、容易实现的小玩意儿开始吧。</p>

<p>要统计浏览器的访问记录，首先要找到访问记录，看起来简单，以为只要随便导出一下就可以了，实际还颇费了一番周折。火狐的历史记录以前是以xml格式存储的，现在则是用数据库格式存储的，位置是在<code>%appdata%\Mozilla\Firefox\Profiles\xxxxx.default\places.sqlite</code>。东西是找到了，可是肿么读出来呢？尼玛是数据库文件啊，我还不会用肿么办呢？google了一番后发现可以用firefox的一个扩展来打开读取，这个扩展叫SQLite Manager，相当赞，各种功能齐全，关键支持csv导出！好的，长话短说，导出为csv文件后就可以请python出场了！</p>

<p>基本步骤是，先从csv文件中按行读出来，这数据库还是蛮大的，共13692条记录，然后从行中提取出需要的网址信息，放入一个列表中，然后再利用字典来统计各个网址的频度，程序如下：</p>

<pre><code>#!/usr/bin/python

import csv
histList=[]
histDict={}
with open('f:\moz_places.csv','rb') as f:
    reader = csv.reader(f)
    for row in reader:
    histList.append('/'.join((row[1].split('/'))[:3]))


for place in histList:
    if place not in histDict:
    histDict[place] = 1
    else:
    histDict[place] += 1

sortedDict = sorted(histDict.iteritems(),key=lambda d:d[1],reverse=True)

for (place,freq) in sortedDict[:50]:
    print '%s\t\t%s' %(freq,place)
</code></pre>

<p>PS，再总结下这几天学到的新东西：</p>

<ul>
<li>splinter。python下的一个网页应用测试库，就是可以操纵浏览器来与网站交互，玩了下还挺好上手，比底层一点的request神马的友好多了，之前还一直坚持不用这种直接操作浏览器的库，嫌太低端，现在看来，还是先从基础开始慢慢来吧。</li>
<li>xpath。一种选择xml文件中节点的方法，通过它可以快速指定html文件中的元素。</li>
<li>css selector。也是为了简化css而出现的，通过它也能快速指定网页中的特定元素。</li>
</ul>


<p>以上两个玩意儿的语法并不是很难，阮一峰的博客中都有介绍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[last day of 2013]]></title>
    <link href="http://cs50Mu.github.io/blog/2013/12/31/last-day-of-2013/"/>
    <updated>2013-12-31T17:23:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2013/12/31/last-day-of-2013</id>
    <content type="html"><![CDATA[<p>今天是2013年最后一天了，不经意间一年又过去了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[五儿子到手了！]]></title>
    <link href="http://cs50Mu.github.io/blog/2013/12/01/nexus5-has-arrived/"/>
    <updated>2013-12-01T20:54:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2013/12/01/nexus5-has-arrived</id>
    <content type="html"><![CDATA[<p>在拿到包裹的时候竟然异常的平静，或许是因为早已经麻木了。对了，感谢政府感谢党，没有睡我。</p>

<p>回顾下整个购买过程：11月20号在日本google play下单，11月21日晚上8点多收到易票联的手机扣款的短信通知，11月22日收到谷歌的发货通知，手机是从香港发出的，11月25日收到转运公司的商品签收通知和转运费用通知，立马通过支付宝付款（才77多），当晚收到付款完成通知，11月26日收到转运公司的商品寄出通知，是用EMS寄的，查询EMS记录显示，手机在11月26日晚上6点被寄出，27日到达北京，28日到达天津，然后当天就送到学校了！！这个速度是让我很吃惊的，国内的EMS突然这么快都让我有点不适应了。。28号那天不停的刷EMS进度，然后看到状态突然从到达处理中心，跳到投递并签收，我和我的小伙伴都惊呆了！赶紧跑到学校收发室，看记录，没有，然后被告知，刚到的邮件还没有登记！又等了一会儿，终于登记完了，过去一看，果然有！！</p>

<p>这样算下来，整个购买从下单到拿到手总共才9天不到！跟美淘比快多了，虽然就是价钱贵了一点点。但是呢，因为第一次海淘，花费的时间成本还挺大的，回头看看，整整一个月搭进去了，从11月初刚发布，就确定要买，只是那时候还期待淘宝呢，后来发现可以海淘，于是就想试试，谁知道是个坑啊，呵呵～～个中辛酸已经在上一篇博客中发过牢骚了，现在只总结下问题，告诫自己不要再犯错误。</p>

<ul>
<li>信用卡。这个是最重要的！！一开始就是死在这上面的！google钱包里注册的信用卡信息必须真实，还必须得是本人的卡，姓名和电话什么的一定要填真实自己的，地址因为没办法选天朝，所以只能用转运公司的。我一开始用朋友的卡，购买人填的我，信用卡信息填的朋友的，也通不过！这时候就看到自己有信用卡的重要性了，借别人的，一个是不方便，不安全；另一个是可能根本就没法下单。。后来实在没办法，看到贴吧里有吧友用易票联支付成功了，才终于支付成功。易票联是一种虚拟信用卡，可以用于境外支付，没有信用卡的同学可以试试它，注册也很方便，立马就能用，不过最好是认证下，我一开始没有实名认证，下单好久都没反映，实名认证人工审核可能需要一两天，也很快。还有就是，通过信用卡网上买东西会有一个提前的扣款，叫预授权扣款，这个不是实际的商品扣款，到时候是会自动返还回来的，不用担心。</li>
<li>VPN。为了海淘专门买了一个月的VPN，因为境外的网站不认中国ip，需要挂vpn才能下单成功，而且最好不要老是更改访问的ip，很容易出问题。</li>
<li>google账户。这个我觉得也是一个问题，一开始我没有申请新的google账户，就用的以前一直用的老账户，一直没有成功，后来重新申请了一个全新的账户才成功了。</li>
</ul>


<p>应该就是这几个问题了，感慨下日淘真的很快啊～！相比较美淘要1个多月，日淘真的是神速啊！而且貌似被睡的几率还很小。以后海淘的话优先选择日淘～～</p>

<p>最后，拿到nexus 5的那一刻，感觉一切的煎熬与等待都值了，因为五儿子真的是太酷了～～拿到五儿子后以前的手机都不忍直视了。。</p>

<p>对了，给五儿子配了张联通3G卡，平生第一次用3G卡，体验还不错，就是淘宝卖家太坑，买前买后180度大变脸，买前亲啊亲啊的叫的好甜啊，付钱后就愛搭不理的，说的很清楚要求剪卡，没剪就送来了，然后还强词夺理不想负责。。还有，这卡应该是假的，卖家承诺的那些返话费可能都没那么久，我之前已经在网上看过很多类似的抱怨，但没办法营业厅里的套餐太贵，用不起。。暂时先买了这个，如果被骗，算个教训，以后淘宝购物一定要谨慎！X宝JS果然不是谣传。2013年12月1日正式开始用的这张联通卡，花了213大洋，我倒要看看到底能用到什么时候，后续会更新。</p>

<p>谨以此献给我的第一次海淘～～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最近各种不顺]]></title>
    <link href="http://cs50Mu.github.io/blog/2013/11/20/bad-days/"/>
    <updated>2013-11-20T20:30:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2013/11/20/bad-days</id>
    <content type="html"><![CDATA[<p>最近一个月都不在状态。</p>

<p>也许是因为停止跑步了？天气一冷就懒得跑了。。唉，最终还是没有坚持下去。</p>

<p>最可恨的是买个谷歌5儿子，从月初就开始买，直到现在愣是没买成功。。唉，搞得我都无力吐槽了，不过也算是知道海淘是怎么回事了。。唉，建议心理承受能力不行的还是别掺和了，虐心啊！因为nexus在伟大的天朝根本不上市，所以只能国外海淘，本来是想去美国google play淘的，贴吧里研究了一下，看到有人说在日本google play下单发货快，虽然要比美国的价格贵多了，但算上运费啥的也贵不了多少。海淘还必须得有国外的ip才行，为了这个还专门买了一个月的vpn帐号，然后注册转运公司。哦，先说下海淘的流程吧，基本工具要有，vpn用来做代理，信用卡用来支付。首先，你得注册一个转运公司，获取到一个你的转运地址，然后去国外google play上下单，用信用卡付款，送货地址就填你注册转运公司获取到的地址，然后就等吧，扣款成功后一般就会发货了。唉，哥就悲剧的卡在付款这个环节上了，一开始是没有信用卡，到处借卡，其实我之前有一张信用卡，但因为年费太高被我注销了。。好不容易借到一张卡，不管怎么填账单信息，google就是不扣款。。别人不是一下订单就扣款就是等了没多久就扣款，可我的订单就是没一点动静。。后来又看到贴吧里有人说没信用卡的用易票联的虚拟信用卡也支付成功了，于是又赶紧注册易票联，手机的钱也打进易票联了，更新名字和电话为自己的真实信息，地址因为无法选中国，只能用转运公司的了，所有这些做完后竟然还是不行！！！跟我同一天下订单的人，人家都收到发货通知了，我的还是一点动静都没，唉，感觉不能再爱了。。</p>

<p>然后就因为一直挺期待五儿子的，搞得每天都没心思了学习了有木有！！感觉好久都没看书了，英语跟读也好久没有进行了。</p>

<p>最后，祸不单行，服务器最近也问题不断，一开始是被顶ip，后来竟然升级到MAC攻击。。还专门在半夜10点11点的时候，也不知道到底是有人故意的还是有人电脑中病毒了，昨天外网网线竟然被剪了，当时听到这个消息我就震惊了，这真是不碰上不知道，什么样的奇葩都有啊。。</p>

<p>吐了这么多槽，其实还是有点好事的，经某大神指点发现宽带竟然可以多拨～～于是，生活又美好了一点点。</p>

<p>以上      by 快要崩溃感觉无法再爱的linuxfish</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[3 amazing days at mangoo hotel]]></title>
    <link href="http://cs50Mu.github.io/blog/2013/10/29/3-amazing-days-at-mangoo-hotel/"/>
    <updated>2013-10-29T20:20:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2013/10/29/3-amazing-days-at-mangoo-hotel</id>
    <content type="html"><![CDATA[<p>2013.10.24-2013.10.27</p>

<p>What happened in these 3 days is a milestone in my life. Thank you, my lover. It&rsquo;s very lucky of me to meet you! Although we both know that we may not end up well eventually, for sure you will be my angel forever. At one moment I thought I would end up all by myself during my entire life, then you came up, brought me this fresh new world!</p>

<p>It&rsquo;s you who makes me realize that if you wanna a change you&rsquo;ve got to make a move first! During the past some twenty years, I was always thinking too much without making any actual moves.</p>

<p>Finally, many thanks for your great patience, baby!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[understand octopress]]></title>
    <link href="http://cs50Mu.github.io/blog/2013/10/13/understand-octopress/"/>
    <updated>2013-10-13T17:42:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2013/10/13/understand-octopress</id>
    <content type="html"><![CDATA[<p>好奇害死猫。</p>

<p>一开始是想着给现在的博客主题添加一个sidebar，再后来就想着搞清楚Octopress的原理，仔细一研究，原来里面用到了好多好玩的新技术啊（对我而言的新技术，我对网页的认识还停留在html css php等），下面就盘点下我从Octopress/Jekyll里了解到的“新”技术。</p>

<ul>
<li>Octopress是Jekyll的一个wrapper程序，Jekyll transform your plain text into static websites and blogs. Jekyll是一个静态博客编译器，负责把你写的代码编译成一个完整的博客网站。这样生成的网站属于静态网站，它是想对于wordpress这样的带数据库的动态网站而言的。很显然，静态网站的一大优点就是响应速度比动态网站相对要快，因为所有页面一旦生成就不再改变了嘛，不需要跟跟数据库交互；缺点就是每次更新都需要重新编译。</li>
<li><p>Sass &amp;&amp; Compass。这年头写CSS是用Sass和Compass了，我已经OUT了太久了。CSS不是一种编程语言，没有变量，没有条件语句，只是一行行的描述，写起来很费事，于是程序员童鞋忍不住了，Sass诞生了！Sass是一种CSS的开发工具，提供了很多便利的写法，可大大节省设计者的时间，使得CSS的开发变得简单。Compass是Sass的工具库(toolkit)，Sass本身只是一个编译器，Compass在它的基础上，封装了一系列有用的模板，使得CSS的开发更加便利！它们之间的关系，类似Javascript和jQuery、python和Django的关系。  <br/>
<strong>说到这里我可以自我鄙视下嘛？人家其实连CSS都不会。。</strong> 唉，各种标签、类一会儿就被转晕了。。</p></li>
<li><p>YAML。递归的名字是YAML Ain&rsquo;t Markup Language，官方给出的定义：YAML is a human friendly data serialization
standard for all programming languages.也就是说它是一种数据表示的标准，类似于xml，实际上是将来可能会取代xml的数据标准，YAML试图用一种比XML更敏捷的方式，来完成XML所完成的任务。我的感觉是，YAML确实比xml和jason更容易阅读，看起来结构比较清楚，容易理解一点。</p></li>
<li>Liquid。Ruby library for rendering safe templates which cannot affect the security of the server they are rendered on.所谓的templating language，模板语言。可以嵌入在web页面中来形成模板页面，后期根据不同的页面参数会编译成不同的页面，甚至还支持使用if for等类编程语句，非常灵活。Jekyll在它的模板文件中大量使用了liquid语言。</li>
<li>FontAwesome。The iconic font designed for Bootstrap.Font Awesome gives you scalable vector icons that can instantly be customized — size, color, drop shadow, and anything that can be done with the power of CSS.Font Awesome是一种出色的免费iconic font，别让字面意思误导了，这货其实不是字体，是网站上用的一些小图标，可能你都没有注意到，但也确实会给网站增色不少。看到一篇介绍iconic font的文章，<a href="http://lepture.com/work/iconic-fonts">Iconic Fonts 簡介</a>，讲的非常不错！我目前用的主题fabric的header里用的字体就是来自google font的Slackey。</li>
<li>Animate.css。animate.css is a bunch of cool, fun, and cross-browser animations for you to use in your projects. Great for emphasis, home pages, sliders, and general just-add-water-awesomeness.用纯CSS实现的动画效果集合，非常酷！ <br/>
How to use it?  <br/>
To use animate.css in your website,simply drop the stylesheet into your document&rsquo;s <code>&lt;head&gt;</code>, and add the class <code>animated</code> to an element, along with any of the animation names.That&rsquo;s it! You&rsquo;ve got a CSS animated element.Super!
关于怎么用CSS3实现动画效果，看<a href="http://www.w3schools.com/css3/css3_animations.asp">这里</a></li>
<li>google web font。顾名思义，是Google提供的网上免费字体。使用方法之一是，首先在<code>&lt;header&gt;</code>里添加对网上字体的引用，比如<code>&lt;link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Tangerine"&gt;</code>，然后就可以在CSS里指定了。</li>
<li><p>fancybox。FancyBox is a tool for displaying images, html content and multi-media in a Mac-style &ldquo;lightbox&rdquo; that floats overtop of web page. It was built using the jQuery library.</p></li>
<li><p>两个html5新标签。通过这番折腾知道了两个新标签<code>&lt;header&gt;</code>和<code>&lt;article&gt;</code></p></li>
<li>Octopress/Jekyll的layouts</li>
</ul>


<p>其实很容易理解的东西，不知为什么搞了很久才弄明白，layouts文件夹里放的是博客的模板文件，顾名思义就是一个框架，相当于人的骨骼，把具体的博客内容填进去后就成了最终的博客。通常为了不同的用途，会有多个模板文件，为了简化代码，这几个模板文件之间通常有继承关系。比如，default.html里放的是所有页面都会有的东西，比如页面开始的引用、head、footer等，post.html在default.html的基础上再做进一步的修改，思想有点类似类的继承，不过在这里只能在原有的基础上继续添加，不能覆盖原来的“方法”。</p>

<p>另外，在某个模板中还可以include进别的模板，比如在default.html中include进foot.html，这样做有利于管理代码，否则所有的代码都在一个文件里，看着混乱，也不容易管理。所有include的模板都在<code>source/_include</code>文件夹里。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ipv6 in cauc?]]></title>
    <link href="http://cs50Mu.github.io/blog/2013/10/11/ipv6-in-cauc/"/>
    <updated>2013-10-11T20:11:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2013/10/11/ipv6-in-cauc</id>
    <content type="html"><![CDATA[<p>经过我将近一天的折腾后，结论是ipv6在CAUC根本不可行。</p>

<p>没来这个学校之前还一直期待教育网的ipv6的呢，来了后才发现，悲剧了。。不要说ipv6了，连基本的v4网络都烂的要死，还不如我本科的学校！想重新进入学校就是想再有个机会体验下教育网的ipv6，因为本科学校没有教育网，一直觉得是个遗憾，谁知。。看来今生是与教育网无缘了。</p>

<p>怎么会突然想起要玩ipv6呢？不是翻墙。缘起是一个师弟问起，学校的网能上六维空间嘛，Google了下是个ipv6的pt站，告之不能，问：我们学校不是教育网嘛？答：。。。。但是也可以连的，通过tunnel就可以。问：tunnel是神马？答：tunnel就是那个那个什么。。 是啊，tunnel到底是什么呢？</p>

<p>目前，在ipv4网络下接入ipv6网络主要有三种方法：</p>

<ul>
<li>ISATAP隧道</li>
<li>6to4隧道</li>
<li>teredo隧道</li>
</ul>


<p>其中，前两种都需要pc机具有公网ipv4地址，不支持NAT后的主机访问。teredo隧道不需要pc机具有公网ipv4地址，可以穿越NAT将ipv6数据包封装在UDP中访问ipv6网络。</p>

<p>一开始没有注意ISATAP隧道不支持非公网ip，白折腾了一顿ISATAP，后来尝试teredo隧道，由于我使用了vpn，还是不行。。快崩溃死了，死了的心都有了，不甘心，找到了一个第三方软件，六飞。装上注册后，看了下可以用，可是六维空间依然访问不了，上网搜索后发现可能是六维空间禁止非教育网的ipv6网络访问。。更悲催的是，我发现那些可以访问的ipv6 pt下载站基本都需要邀请注册！这尼玛不是坑爹嘛？！这样的话，就算是能访问v6网络，也没有多大意义了。</p>

<p>所以，结论就是：如果你的学校不属于教育网，趁早不要折腾ipv6了，没用！</p>

<p>PS: 还有学校的网络不属于教育网？！ 再次吐槽下CAUC坑爹的网络，友情提示下想要报考这个学校的童鞋们，千万不要来这里，这个学校的网络连渣都不如。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[a day to remember]]></title>
    <link href="http://cs50Mu.github.io/blog/2013/10/09/a-day-to-remember/"/>
    <updated>2013-10-09T18:58:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2013/10/09/a-day-to-remember</id>
    <content type="html"><![CDATA[<p>I will never forget that day, Oct 2nd 2013.</p>

<p>Many years later, I&rsquo;ll still remember the day vividly. Lovely weather, cute girl, crowded subway, night walk in Beijing Hutong.. all combined into a wonderful scenery. I&rsquo;m pretty sure that what happened at that night gonna change my life track a little bit.</p>

<p>It&rsquo;s like one moment you feel like you&rsquo;re disgarded by the whole world, and the next moment the whole world is with you!</p>

<p>YES,love is so wonderful.^_^</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A brand new blog]]></title>
    <link href="http://cs50Mu.github.io/blog/2013/10/08/change-the-default-theme-for-octopress/"/>
    <updated>2013-10-08T15:41:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2013/10/08/change-the-default-theme-for-octopress</id>
    <content type="html"><![CDATA[<p>终于忍不住了。</p>

<ul>
<li><p>添加了disqus评论系统，还是挺简单的，Octopress内建了对disqus的支持，只要去disqus官网注册，然后在Octopress里开启一下就可以用了。具体是在<code>_config.yml</code>中设置。</p></li>
<li><p>换了新主题fabric，好酷啊～～，竟然还有javascript特效！以前想着换主题应该挺麻烦，现在看来挺简单的，就是输几条命令而已：</p>

<pre><code>  $ cd octopress
  $ git clone git://github.com/panks/fabric.git .themes/fabric
  $ rake install['fabric']
  $ rake generate
</code></pre></li>
<li>添加了tag或category功能。其实，这个本来就有的，只是我不知道而已。。在每篇文章开始添加上category参数后它就有标签了～～一篇文章可以添加多个标签哦～</li>
</ul>


<p>于是，现在的博客是这个样子的。。有种屌丝一秒变高帅富的感觉有木有？！
<img class="center" src="http://cs50Mu.github.io/images/newTheme.png">
一个小tip，有时候可能会有一些帖子不想发布出去的，那要肿么办呢？  <br/>
其实也很简单，在文章开头的参数中添加<code>published: false</code>，就可以隐藏文章(但其实已经发布到github了)，要公开文章只需要将参数改为<code>true</code>即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[confused about cronie]]></title>
    <link href="http://cs50Mu.github.io/blog/2013/10/08/confused-about-cronie/"/>
    <updated>2013-10-08T11:49:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2013/10/08/confused-about-cronie</id>
    <content type="html"><![CDATA[<p>昨天想要为每日一图脚本添加定时运行时才发现，貌似crond不工作了。  <br/>
于是发现原来的dcron早就被踢进AUR了，现在的crond是cronie童鞋。。可是要肿么用呢？</p>

<p>发现Archlinux论坛上也有人有这样的疑问，思路整理如下：</p>

<p>目前，可以使用<code>crontab -e</code>来添加命令或者把想定时运行的命令放在相应的<code>cron.{hourly,daily,monthly,weekly}</code>文件夹中。两者的区别是，通过<code>crontab -e</code>添加的任务可以指定具体的运行时间，可以精确到分钟，但需要保证机器一直运行，若在指定的时间点计算机没有在线，那么任务就不会运行；而放在那几个文件夹的脚本不可以指定精确的运行时间，但不要求计算机一直在线，计算机一旦在线就会检查相应文件夹下的脚本是否应该执行，若符合执行的条件则执行。那么它是通过什么方法来检查的呢？配置文件<code>/etc/anacrontab</code>的一个字段<code>period in days</code>指定了某个文件夹下的脚本的运行间隔时间，若计算机看到某个脚本距上次执行时间已经有n天或大于n天，那么它就会运行这个脚本。  <br/>
以下的专业解释来自Man，哈哈</p>

<blockquote><p>Anacron  is used to execute commands periodically, with a frequency specified in days.  Unlike cron(8),it does not assume that the machine is running continuously.  Hence, it can be used  on  machines  that are not running 24 hours a day to control regular jobs as daily, weekly, and monthly jobs.</p>

<p>Anacron  reads  a  list  of jobs from the /etc/anacrontab configuration file (see anacrontab(5)).  This file contains the list of jobs that Anacron controls.  Each job entry specifies a  period  in  days, a delay in minutes, a unique job identifier, and a shell command.</p>

<p>For each job, Anacron checks whether this job has been executed in the last n days, where n is the time period specified for that job.  If a job has not been executed in n days  or  more,  Anacron  runs  the job&rsquo;s shell command, after waiting for the number of minutes specified as the delay parameter.</p>

<p>After  the  command exits, Anacron records the date (excludes the hour) in a special timestamp file for that job, so it knows when to execute that job again.</p></blockquote>

<p>To summerize then,if you want to execute a script at a particular time, you should use <code>crontab -e</code>.If you just want the script to execute regardless of the time, you should drop it in the appropriate folder.</p>

<p>做完上面这些后，我悲催的发现crond其实不适合用于定时运行每日一图的脚本。。最后加在awesome的开机启动，通过<code>theme.wallpaper</code>参数可以来设置墙纸，不过有一个矛盾，只能先设置墙纸然后才能下载每日一图。。暂时没找到很好的可以先下载再设置的方法。所以，目前用不了当天的图，用的是前一天的图。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python复习]]></title>
    <link href="http://cs50Mu.github.io/blog/2013/09/30/some-python-practices/"/>
    <updated>2013-09-30T21:47:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2013/09/30/some-python-practices</id>
    <content type="html"><![CDATA[<p>发现了一本学python的好书，额，起码感觉很对我的口味。。名字叫<strong>The Practice of Computing Using Python</strong>，中译名很二，叫《Python入门经典》。。这本书是美国密歇根州立大学的教材，这本书很好的一点是教会了我如何一点一点的来实现复杂的程序，也就是如何把一个看似很复杂的任务分拆成几个小任务，或者先实现一个很简略的版本，然后再一点一点的去优化，增加新功能，直至完成！</p>

<p>书中在程序开发进阶一章中讲到了一点机器学习(machine learning)的东西，例子是一个预测乳腺癌的程序，基本的过程是这样的：首先，有一个数据样本，样本的参数是肿瘤的属性描述和是否为良性和恶性肿瘤的诊断结果，程序读入数据样本来构造分类器，构造的方法是，分别求出良性和恶性肿瘤的属性的平均值，然后再求这两个平均值的平均值，最后用这个分类器去预测一个肿瘤是良性还是恶性的。预测的方法是投票，若某个属性倾向于良性属性，则良性记一票，反之，恶性记一票，统计所有的属性，票数多者取胜。</p>

<p>课后有一个类似的练习是预测成人的收入，用的还是UCI的机器学习资源库的数据集，不过不同的是这个数据样本里还有一些离散的属性，也就是不是一个具体的数值，是几个选项参数，比如，性别属性，当然只有男女了，国籍属性，当然就是那几个国家了，题目里没有说该怎么处理这类属性（或者说了我没有看懂），我想了个方法，根据收入大于5万和小于5万的分成两类，就某一类来说，对于某个离散属性，统计样本中该属性的分布情况，比如，国籍属性，就统计大于5万的人中美国的有多少个，加拿大的有多少个，英国的有多少个等等，然后找最大的作为这个属性的代表，也就是说在以后预测的时候，如果这个人这个属性的值是这个最大的值（或者说最流行的）的话就投一票。可惜实现起来有些问题，后来在写程序的过程中发现，有几个属性在两类中最大的那个都是一样的。。那这样就没什么意义了啊。。于是又想了一招，把那些离散属性的分布情况按从大到小排序，然后挨个比较，相同的话就继续往下找，直到找到最大的且不同的为止，恩，其它的非离散的参数跟例子是一样的处理，结果。。很不理想，预测的结果有20%的错误。。</p>

<p>以下是在看书过程中做的笔记</p>

<p>看到一篇讲编码的文章，来自<a href="http://ipie.blogbus.com/logs/19379694.html">这里</a>，看了后总算不那么迷糊了。</p>

<p>首先要搞清楚，字符串在Python内部的表示是unicode编码，因此，在做编码转换时，通常需要以unicode作为中间编码，即先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。</p>

<p>decode的作用是将其他编码的字符串转换成unicode编码，如str1.decode(&lsquo;gb2312&rsquo;)，表示将gb2312编码的字符串转换成unicode编码。</p>

<p>encode的作用是将unicode编码转换成其他编码的字符串，如str2.encode(&lsquo;gb2312&rsquo;)，表示将unicode编码的字符串转换成gb2312编码。</p>

<p>在某些IDE中，字符串的输出总是出现乱码，甚至错误，其实是由于IDE的结果输出控制台自身不能显示字符串的编码，而不是程序本身的问题。如在UliPad中运行如下代码：</p>

<pre><code>s=u"中文"
print s
</code></pre>

<p>会提示：UnicodeEncodeError: &lsquo;ascii&rsquo; codec can&rsquo;t encode characters in position 0-1: ordinal not in range(128)。这是因为UliPad在英文WindowsXP上的控制台信息输出窗口是按照ascii编码输出的（英文系统的默认编码是ascii），而上面代码中的字符串是Unicode编码的，所以输出时产生了错误。</p>

<p>将最后一句改为：<code>print s.encode('gb2312')</code></p>

<p>则能正确输出“中文”两个字。</p>

<p>若最后一句改为：<code>print s.encode('utf8')</code></p>

<p>则输出：<code>\xe4\xb8\xad\xe6\x96\x87</code>，这是控制台信息输出窗口按照ascii编码输出utf8编码的字符串的结果。</p>

<p>另外，代码中字符串的默认编码与代码文件本身的编码一致，如：</p>

<pre><code>s='中文'
</code></pre>

<p>如果是在utf8的文件中，该字符串就是utf8编码，如果是在gb2312的文件中，则其编码为gb2312。 这种情况下，要进行编码转换，都需要先用decode方法将其转换成unicode编码，再使用encode方法将其转换成其他编码。通常，在没有指定特定的编码方式时，都是使用的系统默认编码创建的代码文件，在这篇文章中可以看到如何获得系统的默认编码。</p>

<p>如果字符串是这样定义：</p>

<pre><code>s=u'中文'
</code></pre>

<p>则该字符串的编码就被指定为unicode了，即python的内部编码，而与代码文件本身的编码无关。因此，对于这种情况做编码转换，只需要直接使用encode方法将其转换成指定编码即可。</p>

<p>如果一个字符串已经是unicode了，再进行解码则将出错，因此通常要对其编码方式是否为unicode进行判断：</p>

<pre><code>isinstance(s, unicode)  #用来判断是否为unicode
</code></pre>

<p><strong>以下是才是读书笔记哦亲～～</strong></p>

<p><em>关于复制</em>   <br/>
python中分为深copy和浅copy。只复制引用，而不复制对象本身的情况，称为浅copy。复制对象内容，称为深copy。对于单个列表，深copy可以用[:]分片复制来实现；而对于
列表的列表等复杂列表结构需要用copy模块的deepcopy函数实现。</p>

<p><em>关于split()函数</em>  <br/>
它在分割字符串的时候会自动把结尾的换行(\n)删除掉</p>

<p><em>关于参数传递  可变对象</em>  <br/>
由于传递的只是对象的引用，所以若对象为可变对象，则若在函数中对可变对象进行了修改，变化会反应在主调函数的实参对象上，这很容易造成莫名其妙的结果，切记！
相应的，对于设置默认值参数也有一个类似的问题，如果默认参数设置为可变对象的话，默认参数会随着函数的调用不断变化。。引发看似很诡异的问题，所以一定不要用可变对象做默认参数！</p>

<p><em>关于字典的copy</em>   <br/>
newDict=myDict.copy()  注意，这依然是浅copy，会影响到字典中的可变对象。
字典排序：先用列表解析转化为列表[(val,key) for key,val in d.items()]，然后再用列表的sort方法即可。
键值交换：</p>

<pre><code>  for (k,v) in d.items():
        d2[v]=k
</code></pre>

<p><em>关于作用域</em>  <br/>
作用域搜寻遵照LEGB规则(local/eclosing(指封闭在函数中的函数)/global/built-in)</p>

<p><em>关于文件</em></p>

<ul>
<li>跳过第一行

<ol>
<li> 先使用readline()，再用for循环</li>
<li> 用next(f)跳过</li>
</ol>
</li>
<li>换行符：针对不同平台的不同标准，使用U修饰符可以由python统一解决，无需你操心。fd=open(&lsquo;file.txt&rsquo;,&lsquo;rU&rsquo;)文件内的移动：seek，fd.tell()报告当前位置，最常用的是fd.seek(0)，回到文件开头</li>
</ul>


<p><em>列表</em>   <br/>
[0]*9=[0,0,0,0,0,0,0,0,0]</p>

<p><em>关于类</em>   <br/>
属性的名字前面有两条下划线时表示这是一个私有属性，不推荐在类外部更改私有属性。如果在类之外使用该属性，python会将属性名字改变，使得访问出错，比如会将<code>_attribute</code>改为<code>_className__attribute</code></p>

<p><em>关于运算符重载</em>   <br/>
python首先会用自检来检查参数的类型，再确定操作方式，若没有合适的操作，则会报错。  <br/>
修复int+Rational的错误，Rational是新建的一个类，那么1+Rational(1,2)会报错，但又不可能修改int类为它添加针对Rational类的<code>__add__()</code>方法，那肿么办呢？答案是<code>__radd__()</code>方法，在Rational类中新加一个<code>__radd__()</code>方法，那么，python在计算1+Rational(1,2)时的步骤是这样的：首先尝试为int类型找到合适的带Rational参数的方法，可惜没找到，那么python开始在第二个操作类即Rational类查找<code>__radd__()</code>方法，如果找到的话，那么python将自动将表达式反转并调用<code>__add__()</code>方法，在这个例子中表达是变为<code>Rational(1,2).__radd__(1)</code>，这样在Rational类中再定义<code>__radd__()</code>方法直接返回<code>__add__()</code>的结果即可，因为加法是可交换的。</p>

<p><em>捕获开发者犯的错误</em>   <br/>
try-except是用来捕获用户犯的错误，而assert是用来捕获用户犯的错误，assert函数有两个参数，第一个参数是布尔值，如果为真，代码继续；如果为假，则引发assertionError。第二个参数是用于显示错误提示信息的。</p>

<p><em>测试模块</em>   <br/>
doctest  unittest</p>

<p><em>递归</em>    <br/>
1. 递归的思想是通过调用自身的函数来实现的，递归的主要思想还是分治，把一个大问题不断的分解成小的问题，直到最小的问题，而最小的问题是有答案的，最后，再把较小的解决方案重新组合成整体方案。  <br/>
2. 递归是如何实现的呢？是通过栈(stack)来实现的，栈是一种后进先出的数据结构，计算机通过栈来对函数的调用进行跟踪。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[two more books about macro economics]]></title>
    <link href="http://cs50Mu.github.io/blog/2013/09/11/two-more-books-about-macro-economics/"/>
    <updated>2013-09-11T12:18:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2013/09/11/two-more-books-about-macro-economics</id>
    <content type="html"><![CDATA[<h3>《一转念》 by 兰小欢</h3>

<p>书中大部分内容讲的是用经济学的供求原理来解释生活中一些看似古怪的现象，还有一些作者的随想。以下是摘录：</p>

<p>你要是把喜儿都霸占了，那大春儿可就要参军了</p>

<p>表再谈神马公平了，一切都是供求惹的祸啊！这是我看到文中关于剩女与光棍的分析后不由得发出的感叹，一直以来总是理想主义的固执认为既然要求男女公平，那就一切都要公平，凭什么男生要买房，女生就什么都不用做？唉，供求决定地位、话语权啊！要怪也只能怪自己生不逢时，不说了，都是泪。</p>

<p>为什么专制会培育仇恨？</p>

<ul>
<li>教育根植偏见</li>
<li>信息流通不畅</li>
<li>权力分配极度不均</li>
</ul>


<p>一旦官府认真发起对妖术的清剿，普通人就有了很好的机会来清算宿怨或谋取私利。这是扔在大街上的上了膛的武器，
每个人——无论恶棍或良善——都可以取而用之。在这个权力对普通民众来说向来稀缺的社会里，以“叫魂”罪名来恶意中伤他人成了普通人的一种突然可得的权力。</p>

<p>业余读书，除了天才诗人的诗歌，没有什么东西值得一个字一个字读的。而若为增长见识，那最重要的是<strong>主动思考而不是被动阅读</strong>，要努力提炼自己的东西，与别人互相比照，否则不如放下书本出门去旅行。</p>

<p>做学问的六个阶段：</p>

<ul>
<li>第一阶段是“信”，真心的信，诚心诚意地信，切忌一上来就“疑”，一上来就“不屑”，一上来就认为教授水平不过如此，不过故作高深。</li>
<li>第二阶段是“疑”，觉得曾经所学皆不可信，都是胡说八道。这是因为学多了，学久了，学深了，越学越难，每前进一步付出的代价和努力越来越大，往往还不甚了了，此时怀疑，其实多半是一种消极的心理作祟。</li>
<li>第三阶段是“悟”</li>
<li>第四阶段是“博”</li>
<li>第五阶段是“言”</li>
<li>第六阶段是“无知”</li>
</ul>


<h3>《王二的经济学故事》  by 郭凯</h3>

<p>很好的一本书，看着作者的理智分析真的是一种享受。</p>

<h4>关于分配</h4>

<p>现在的贫富不均越来越大的现象并不全是贪污腐败的原因，美国的贪污腐败相对要少一些，但它的贫富差距依然越来越大。
只要是市场经济，就必然有人做得好，有人做得坏，因而也就出现了贫富差距。</p>

<p>中国目前的经济环境非常不公平，体现在：利率偏低，结果是老百姓补贴银行和企业；汇率偏低，结果是中国老百姓补贴外国人和出口商。</p>

<p>恍然大悟：从某种意义上说，分配不均是现代市场经济的一个必然产物，因为市场本身就是一个能者多得，适者生存的地方，农耕社会很少出现分配不均是因为，不均的分配会直接导致吃不饱穿不暖，会影响生存问题。</p>

<h4>关于收税</h4>

<p>讨论税负高不高，一个很关键的变量是政府通过收税所提供的服务和公共产品的质量和数量如何。</p>

<p>所得税和增值税：所得税可能会被高收入阶层逃掉，因为他们的收入可以不体现为工资，但增值税几乎不可能被逃掉，因为只要你买东西就要交增值税。这样看来，增值税似乎更公平一点，毕竟高收入人群花费也很大，花费越大，交税也越多。</p>

<p>该不该收月饼税？问题实质是该不该对实物征税。答案是非常该，因为不征的结果是很多高收入阶层利用这个漏洞来逃税，该发奖金的时候不发，发月饼，送旅游服务，反正就是不以钱的形式出现，也就避免了交税，从而导致贫富差距加大。</p>

<h4>关于房地产</h4>

<p>中国的低息政策和缺乏好的投资渠道，使得房产成为很有吸引力的投资品。政府的限购令往往越限越高，不从本质上解决问题，违反市场规律强制的改变价格往往事与愿违。限购令实质上是地域歧视，只会加剧本来就不公平的户籍制度，其实要想限制投资购房的需求，不必非要限购，还有好多方法：加息、提高房贷首付比例、征收物业税、增加土地和住房供应、增加房屋短期买卖的交易费用。</p>

<h4>关于汇率</h4>

<p>中国目前实行的是固定汇率，而欧美实行的是浮动汇率，固定汇率不能随着经济形势的变化灵活变动。</p>

<p>人民币对美元升值就意味着中国的外汇储备减少吗？不见得。用人民币来衡量的话，当然少了，但用美元来衡量的话，根本没有变。因此，考虑到外汇储备肯定是用来买老外的东西的，又不是用来买国内的东西的，所以人民币升值后中国的外汇储备并没有变。用人民币衡量导致的损失，是已经发生过的损失，也就是说我们以前对人民币的价值低估了，这些损失是过去这些年中国补贴外国消费者的一个度量。</p>

<p>老美老吆喝着要人民币升值，对他们有好处吗？答：不见得。人民币升值会引发中国出口产品价格的升高，导致美国消费者必须面对更高的价格，购买了更少的东西。</p>

<h4>关于货币政策</h4>

<p>中国目前还是通过调整货币数量来控制货币政策，而不是通过价格也就是利率来调整，而市场中流通的货币量已经越来越难统计清楚，从而使的这种货币政策失灵。</p>

<p>根据一价定律，中国实行固定汇率会将通货膨胀传染到中国来，因为根据一价定律，一件东西刨去运输成本，应该在两地卖一样的价格，因此，若中国的东西便宜，外国的东西贵，若实行固定汇率，那迟早中国的东西也会贵起来，但若实行浮动汇率的话，人民币可以升值，就可以避免自己国家的东西价格上涨，也就避免了通货膨胀。</p>

<h4>关于经济政策的误解</h4>

<p>贸易顺差大就一定会有顺差吗？中国的贸易顺差总是被解释成因为中国的对外贸易大部分是加工贸易，所以出口就一定会大于进口的，因此就一定会出现顺差。但你也可以买别的啊，重要的是交易到你需要的东西，赚了钱在家不用就是一堆废纸啊！这就跟一个人只会赚钱不会花还整天吹自己很有钱是一个道理嘛
所以，作者在书中问道：一个只愿意赚别人钱却不愿意让别人赚钱的国家，最终的结果就是辛苦替全世界打工却不要回报，你不买别人的东西，最终要那么多钱又是为什么呢？</p>

<p>民粹主义的危险。民粹主义是一种危险的政策取向，但又是一种对政治家充满了诱惑的政策取向。危险，是因为这些政策用一时、局部或者不可持续的利益来换取民众的支持，最终伤害的却是同样一批人最终和长远的利益。充满诱惑，则是因为这样的政策往往很有市场，让政客总有动力告诉老百姓他们想听的，而悄悄隐藏那些困难的选择。
在中国收入差距日益拉大的今天，民粹主义者想：既然短期改变不了人群分化的现状，那就采取一些短期的政策让人少抱怨一点。抱怨房价，我就打压房价；有车的抱怨堵车，我就让没车的别买车。这样做更多的是引进新的扭曲，牺牲一部分人沉默的人而让另一部分抱怨的响的人得益。</p>

<p>盗版的误区。如果知识产权得到保护，大家都用正版，那正版的价格很可能会大幅度下降。软件公司把软件价钱定这么高，完全是处于无奈，因为定低了还是没人卖，还不如定高点宰那些愿意出钱的人，毕竟能多赚点就多赚点嘛。这跟我们平常的普遍认识：价钱太高，所以只能用盗版，因果是颠倒的。正版的高价不是盗版的原因，而是盗版的结果。</p>

<h4>关于发展模式</h4>

<p>GDP的增长主要靠消费、投资、出口，而投资是在短期内最容易被影响的，投资就要寻找市场，在更困难的培育和开发国内市场和更简单的低价给国外企业代工之间，企业选择了后者，而我们的政策也用固定的低汇率来支持它们。低利率和低汇率对中国的投资和出口都是好消息，但背后隐藏着对投资和出口的巨大补贴。这些补贴，最终都来自中国的老百姓。老板们都有钱了，老百姓却没有钱。老百姓收入增长缓慢，当然就没有什么购买力了，内需就不强劲，但GDP还要继续增长啊，那就只能继续维持低利率、低汇率，促进出口和投资。
低利率、低汇率和低排放成本、低能源成本，彻底扭曲了中国的产业结构。这种扭曲的一个集中体现就是，中国的经济极度的资本密集、能源密集、污染密集，却创造不出足够的就业，特别是大学生就业。原因是代工企业需要都是一些简单的工作，不需要什么高科技人才。</p>
]]></content>
  </entry>
  
</feed>
