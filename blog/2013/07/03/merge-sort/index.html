
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>归并排序的非递归算法 - The Hard Way Is Easier</title>
  <meta name="author" content="linuxfish">

  
  <meta name="description" content="归并排序的效率很高，复杂度只有NlogN，但想起来很费劲啊。。尤其是递归算法，绕来绕去的被绕晕了。。今天在看《Python编程实践》（Practical Programming-An Introduction to Computer Science Using Python） &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://cs50Mu.github.io/blog/2013/07/03/merge-sort">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="The Hard Way Is Easier" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">The Hard Way Is Easier</a></h1>
  
    <h2>learn one thing at a time</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:cs50Mu.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">归并排序的非递归算法</h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-03T21:24:00+08:00" pubdate data-updated="true">Jul 3<span>rd</span>, 2013</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>归并排序的效率很高，复杂度只有NlogN，但想起来很费劲啊。。尤其是递归算法，绕来绕去的被绕晕了。。今天在看《Python编程实践》（Practical Programming-An Introduction to Computer Science Using Python）时看到一个归并排序的非递归算法，很好理解，记录下。</p>

<pre><code>def merge(L1,L2):
    """Merge sorted lists L1 and L2 and return the result."""
    mergedlist = []
    i1 = i2 = 0 
    while i1 != len(L1) and i2 != len(L2):
    if L1[i1] &lt;= L2[i2]:
        mergedlist.append(L1[i1])
        i1 += 1
    else:
        mergedlist.append(L2[i2])
        i2 += 1

    mergedlist.extend(L1[i1:])
    mergedlist.extend(L2[i2:])
    return mergedlist

def mergesort(L):
    """Sort L."""

    workspace = []
    for i in range(len(L)):
    workspace.append([L[i]])

    count = 0
    while count &lt; len(workspace)-1:
    newList = merge(workspace[count],workspace[count+1])
    print newList
    workspace.append(newList)
    count += 2

    return workspace[-1][:]
</code></pre>

<p>归并排序的基本思想是这样的，从归并两个字来看我们知道这种算法是通过合并子序列来实现的，普通的乱序序列肯定是不行的，但对于两个已经排好序的序列，很容易把它们合并成一个有序的序列，这就是第一个函数merge的作用。你会问：这有什么用啊？离我们的目标还差很远嘛！我们怎么可能从一个无序的序列变出两个有序的序列嘛？别急，这里用到了二分法的思想（so-called devide and conquer），不断的把问题二分化，直到最简单的情形，在这里也就是单个元素了，两个单个元素肯定是两个有序的序列啊！可以用merge函数来合并它们为一个含有两个元素的有序序列，那么第二个函数mergesort的作用就是：首先把无序列表分解成含有N个含单个元素的小列表，然后依次两两合并这些小列表，并把合并后的有序列表添加到这个列表之后，直到最后合并成一个有序的列表。</p>

<p>额，表达能力太差了。。还是没有讲清楚</p>

<p>比如列表原来为[8,7,6,5,4]，那么它的变化为<code>[[8],[7],[6],[5],[4]]--&gt;[[8],[7],[6],[5],[4],[7,8]]--&gt;[[8],[7],[6],[5],[4],[7,8],[5,6]]--&gt;[[8],[7],[6],[5],[4],[7,8],[5,6],[4,7,8]]--&gt;[[8],[7],[6],[5],[4],[7,8],[5,6],[4,7,8],[4,5,6,7,8]]</code> <br/>
结果列表的最后一个内嵌列表就是已排好序的序列了。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">linuxfish</span></span>

      








  


<time datetime="2013-07-03T21:24:00+08:00" pubdate data-updated="true">Jul 3<span>rd</span>, 2013</time>
      


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2013/06/30/fuck-gfw/" title="Previous Post: 操蛋的GFW">&laquo; 操蛋的GFW</a>
      
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/07/03/merge-sort/">归并排序的非递归算法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/06/30/fuck-gfw/">操蛋的GFW</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/06/21/flash-openwrt-in-wr703n/">在WR703N上刷openwrt</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/06/16/regular-expressions/">学习正则表达式</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/06/12/memo-about-octopress/">Octopress搭建备忘</a>
      </li>
    
  </ul>
</section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - linuxfish -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
