<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Golang | The Hard Way Is Easier]]></title>
  <link href="http://cs50Mu.github.io/blog/categories/golang/atom.xml" rel="self"/>
  <link href="http://cs50Mu.github.io/"/>
  <updated>2021-01-22T20:12:08+08:00</updated>
  <id>http://cs50Mu.github.io/</id>
  <author>
    <name><![CDATA[linuxfish]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[database/sql 源码学习]]></title>
    <link href="http://cs50Mu.github.io/blog/2019/10/17/golang-database-sql/"/>
    <updated>2019-10-17T23:30:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2019/10/17/golang-database-sql</id>
    <content type="html"><![CDATA[<h3>数据结构</h3>

<h4>ColumnType</h4>

<p>contains the name and type of a column. 用于表示数据库表字段的基本信息</p>

<h4>Conn</h4>

<p>represents a single database connection rather than a pool of database connections. 只代表一个数据库连接，适用于只能对一个连接操作的场景，比如开启事务。</p>

<p>```go
  type Conn struct {</p>

<pre><code>  db *DB

  // closemu prevents the connection from closing while there
  // is an active query. It is held for read during queries
  // and exclusively during close.
  closemu sync.RWMutex

  // dc is owned until close, at which point
  // it's returned to the connection pool.
  dc *driverConn

  // done transitions from 0 to 1 exactly once, on close.
  // Once done, all operations fail with ErrConnDone.
  // Use atomic operations on value when checking value.
  done int32
</code></pre>

<p>  }
```</p>

<h4>DB</h4>

<p>a database handle representing a pool of zero or more underlying connections. It&rsquo;s safe for concurrent use by multiple goroutines. 代表一个数据库连接池</p>

<p>The sql package creates and frees connections automatically; it also maintains a free pool of idle connections. 连接池由包自动管理</p>

<p>Once DB.Begin is called, the returned Tx is bound to a single connection.Once Commit or Rollback is called on the transaction, that transaction&rsquo;s connection is returned to DB&rsquo;s idle connection pool. 如果是事务的话，在事务提交或回滚前始终用的是一个连接</p>

<p>```go
  type DB struct {</p>

<pre><code>  // Atomic access only. At top of struct to prevent mis-alignment
  // on 32-bit platforms. Of type time.Duration.
  waitDuration int64 // Total time waited for new connections.

  connector driver.Connector
  // numClosed is an atomic counter which represents a total number of
  // closed connections. Stmt.openStmt checks it before cleaning closed
  // connections in Stmt.css.
  numClosed uint64

  mu           sync.Mutex // protects following fields
  freeConn     []*driverConn
  connRequests map[uint64]chan connRequest
  nextRequest  uint64 // Next key to use in connRequests.
  numOpen      int    // number of opened and pending open connections
  // Used to signal the need for new connections
  // a goroutine running connectionOpener() reads on this chan and
  // maybeOpenNewConnections sends on the chan (one send per needed connection)
  // It is closed during db.Close(). The close tells the connectionOpener
  // goroutine to exit.
  openerCh          chan struct{}
  resetterCh        chan *driverConn
  closed            bool
  dep               map[finalCloser]depSet
  lastPut           map[*driverConn]string // stacktrace of last conn's put; debug only
  maxIdle           int                    // zero means defaultMaxIdleConns; negative means 0
  maxOpen           int                    // &lt;= 0 means unlimited
  maxLifetime       time.Duration          // maximum amount of time a connection may be reused
  cleanerCh         chan struct{}
  waitCount         int64 // Total number of connections waited for.
  maxIdleClosed     int64 // Total number of connections closed due to idle.
  maxLifetimeClosed int64 // Total number of connections closed due to max free limit.

  stop func() // stop cancels the connection opener and the session resetter.
</code></pre>

<p>  }
```</p>

<h4>driverConn</h4>

<p>wraps a driver.Conn with a mutex, to be held during all calls into the Conn 封装了 driver.Conn</p>

<p>```go
  type driverConn struct {</p>

<pre><code>  db        *DB
  createdAt time.Time

  sync.Mutex  // guards following
  ci          driver.Conn
  closed      bool
  finalClosed bool // ci.Close has been called
  openStmt    map[*driverStmt]bool
  lastErr     error // lastError captures the result of the session resetter.

  // guarded by db.mu
  inUse      bool
  onPut      []func() // code (with db.mu held) run when conn is next returned
  dbmuClosed bool     // same as closed, but guarded by db.mu, for removeClosedStmtLocked
</code></pre>

<p>  }
```</p>

<h4>Rows</h4>

<p>the result of a query. Its cursor starts before the first row of the result set. Use Next to advance from row to row. 代表查询结果集</p>

<p>```go
  type Rows struct {</p>

<pre><code>  dc          *driverConn // owned; must call releaseConn when closed to release
  releaseConn func(error)
  rowsi       driver.Rows
  cancel      func()      // called when Rows is closed, may be nil.
  closeStmt   *driverStmt // if non-nil, statement to Close on close

  // closemu prevents Rows from closing while there
  // is an active streaming result. It is held for read during non-close operations
  // and exclusively during close.
  //
  // closemu guards lasterr and closed.
  closemu sync.RWMutex
  closed  bool
  lasterr error // non-nil only if closed is true

  // lastcols is only used in Scan, Next, and NextResultSet which are expected
  // not to be called concurrently.
  lastcols []driver.Value
</code></pre>

<p>  }
```</p>

<p>总结一下：</p>

<p>DB对象代表了一个连接池，它来维护这个池子的生长</p>

<p>driverConn代表了一个具体的数据库连接，每一条sql的执行最终都会落实到一个具体的driverConn</p>

<p>一次Query查询会返回一个Rows对象，代表的是一个查询集合，里面是一行一行的记录</p>

<p>其它公开的数据结构（Stmt、Tx）都是构建于上面说的结构之上的</p>

<h3>接口</h3>

<p><code>database/sql</code>包里没有对任何一个数据库协议的具体实现，它只是用一堆接口描述了任何一个想要接入该包的数据库驱动需要实现的函数</p>

<h4>driver.Conn</h4>

<p>a connection to a database. It is not used concurrently by multiple goroutines.</p>

<p>```go
  type Conn interface {</p>

<pre><code>  // Prepare returns a prepared statement, bound to this connection.
  Prepare(query string) (Stmt, error)

  // Close invalidates and potentially stops any current
  // prepared statements and transactions, marking this
  // connection as no longer in use.
  //
  // Because the sql package maintains a free pool of
  // connections and only calls Close when there's a surplus of
  // idle connections, it shouldn't be necessary for drivers to
  // do their own connection caching.
  Close() error

  // Begin starts and returns a new transaction.
  //
  // Deprecated: Drivers should implement ConnBeginTx instead (or additionally).
  Begin() (Tx, error)
</code></pre>

<p>  }
```</p>

<p>注意，Conn 接口要求必须实现Prepare方法</p>

<h3>流程分析</h3>

<p>从官方文档的一个例子开始</p>

<p>```go
package main</p>

<p>import (</p>

<pre><code>"context"
"database/sql"
"flag"
"log"
"os"
"os/signal"
"time"
</code></pre>

<p>)</p>

<p>var pool *sql.DB // Database connection pool.</p>

<p>func main() {</p>

<pre><code>id := flag.Int64("id", 0, "person ID to find")
dsn := flag.String("dsn", os.Getenv("DSN"), "connection data source name")
flag.Parse()

if len(*dsn) == 0 {
    log.Fatal("missing dsn flag")
}
if *id == 0 {
    log.Fatal("missing person ID")
}
var err error

// Opening a driver typically will not attempt to connect to the database.
pool, err = sql.Open("driver-name", *dsn)
if err != nil {
    // This will not be a connection error, but a DSN parse error or
    // another initialization error.
    log.Fatal("unable to use data source name", err)
}
defer pool.Close()

pool.SetConnMaxLifetime(0)
pool.SetMaxIdleConns(3)
pool.SetMaxOpenConns(3)

ctx, stop := context.WithCancel(context.Background())
defer stop()

appSignal := make(chan os.Signal, 3)
signal.Notify(appSignal, os.Interrupt)

go func() {
    select {
    case &lt;-appSignal:
        stop()
    }
}()

Ping(ctx)

Query(ctx, *id)
</code></pre>

<p>}</p>

<p>// Ping the database to verify DSN provided by the user is valid and the
// server accessible. If the ping fails exit the program with an error.
func Ping(ctx context.Context) {</p>

<pre><code>ctx, cancel := context.WithTimeout(ctx, 1*time.Second)
defer cancel()

if err := pool.PingContext(ctx); err != nil {
    log.Fatalf("unable to connect to database: %v", err)
}
</code></pre>

<p>}</p>

<p>// Query the database for the information requested and prints the results.
// If the query fails exit the program with an error.
func Query(ctx context.Context, id int64) {</p>

<pre><code>ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
defer cancel()

var name string
err := pool.QueryRowContext(ctx, "select p.name from people as p where p.id = :id;", sql.Named("id", id)).Scan(&amp;name)
if err != nil {
    log.Fatal("unable to execute search query", err)
}
log.Println("name=", name)
</code></pre>

<p>}
```</p>

<p>首先用<code>Open</code>生成了一个数据库连接池对象，我们看看它是怎么做的</p>

<p>```go
  var (</p>

<pre><code>   // 一把读写锁
  driversMu sync.RWMutex
  // 全局的驱动映射map
  drivers   = make(map[string]driver.Driver)
</code></pre>

<p>  )</p>

<pre><code>func Open(driverName, dataSourceName string) (*DB, error) {
  driversMu.RLock()
  driveri, ok := drivers[driverName]
  driversMu.RUnlock()
  if !ok {
      return nil, fmt.Errorf("sql: unknown driver %q (forgotten import?)", driverName)
  }

  if driverCtx, ok := driveri.(driver.DriverContext); ok {
      connector, err := driverCtx.OpenConnector(dataSourceName)
      if err != nil {
          return nil, err
      }
      return OpenDB(connector), nil
  }

  return OpenDB(dsnConnector{dsn: dataSourceName, driver: driveri}), nil
</code></pre>

<p>  }</p>

<pre><code>func OpenDB(c driver.Connector) *DB {
  ctx, cancel := context.WithCancel(context.Background())
  db := &amp;DB{
      connector:    c,
      openerCh:     make(chan struct{}, connectionRequestQueueSize),
      resetterCh:   make(chan *driverConn, 50),
      lastPut:      make(map[*driverConn]string),
      connRequests: make(map[uint64]chan connRequest),
      stop:         cancel,
  }
  // 注意这里起了两个goroutine

  // 上面的DB的结构体的openerCh字段的注释里说明了
  // 这个goroutine的处理逻辑
  go db.connectionOpener(ctx)
  go db.connectionResetter(ctx)

  return db
</code></pre>

<p>  }
```</p>

<p>那么一次查询是如何进行的呢？</p>

<p>DB.Query 最终会调用到 Conn.Query</p>

<p>```go
  // QueryContext executes a query that returns rows, typically a SELECT.
  // The args are for any placeholder parameters in the query.
  func (db <em>DB) QueryContext(ctx context.Context, query string, args &hellip;interface{}) (</em>Rows, error) {</p>

<pre><code>  var rows *Rows
  var err error
  for i := 0; i &lt; maxBadConnRetries; i++ {
      rows, err = db.query(ctx, query, args, cachedOrNewConn)
      if err != driver.ErrBadConn {
          break
      }
  }
  if err == driver.ErrBadConn {
      return db.query(ctx, query, args, alwaysNewConn)
  }
  return rows, err
</code></pre>

<p>  }</p>

<p>  // Query executes a query that returns rows, typically a SELECT.
  // The args are for any placeholder parameters in the query.
  func (db <em>DB) Query(query string, args &hellip;interface{}) (</em>Rows, error) {</p>

<pre><code>  return db.QueryContext(context.Background(), query, args...)
</code></pre>

<p>  }</p>

<pre><code>func (db *DB) query(ctx context.Context, query string, args []interface{}, strategy connReuseStrategy) (*Rows, error) {
  // 获取一个driverConn
  dc, err := db.conn(ctx, strategy)
  if err != nil {
      return nil, err
  }

  return db.queryDC(ctx, nil, dc, dc.releaseConn, query, args)
</code></pre>

<p>  }</p>

<p>  // QueryContext executes a query that returns rows, typically a SELECT.
  // The args are for any placeholder parameters in the query.
  func (c <em>Conn) QueryContext(ctx context.Context, query string, args &hellip;interface{}) (</em>Rows, error) {</p>

<pre><code>  dc, release, err := c.grabConn(ctx)
  if err != nil {
      return nil, err
  }
  return c.db.queryDC(ctx, nil, dc, release, query, args)
</code></pre>

<p>  }
```</p>

<p>先获取一个connection，这个过程我们暂且不看，继续往下追</p>

<p>从queryDC开始进入驱动的代码</p>

<p>```go
  // queryDC executes a query on the given connection.
  // The connection gets released by the releaseConn function.
  // The ctx context is from a query method and the txctx context is from an
  // optional transaction context.
  func (db <em>DB) queryDC(ctx, txctx context.Context, dc </em>driverConn, releaseConn func(error), query string, args []interface{}) (*Rows, error) {</p>

<pre><code>  // 判断驱动的连接对象是否实现了Queryer接口
  queryerCtx, ok := dc.ci.(driver.QueryerContext)
  var queryer driver.Queryer
  if !ok {
      queryer, ok = dc.ci.(driver.Queryer)
  }
  if ok {
      var nvdargs []driver.NamedValue
      var rowsi driver.Rows
      var err error
      withLock(dc, func() {
          nvdargs, err = driverArgsConnLocked(dc.ci, nil, args)
          if err != nil {
              return
          }
          rowsi, err = ctxDriverQuery(ctx, queryerCtx, queryer, query, nvdargs)
      })
      if err != driver.ErrSkip {
      // 说明用户没有要求用Prepared Statement
          if err != nil {
              releaseConn(err)
              return nil, err
          }
          // Note: ownership of dc passes to the *Rows, to be freed
          // with releaseConn.
          // 注意：这里将驱动返回的行信息rowsi在这里封装成了
          // sql.Rows
          rows := &amp;Rows{
              dc:          dc,
              releaseConn: releaseConn,
              rowsi:       rowsi,
          }
          rows.initContextClose(ctx, txctx)
          return rows, nil
      }
  }
  // 如果驱动没有实现Queryer接口或者用户指定要使用Prepared Statement(返回了driver.ErrSkip），则使用Prepared Statement来做查询

  var si driver.Stmt
  var err error
  withLock(dc, func() {
      // prepare
      si, err = ctxDriverPrepare(ctx, dc.ci, query)
  })
  if err != nil {
      releaseConn(err)
      return nil, err
  }

  ds := &amp;driverStmt{Locker: dc, si: si}
  // 执行查询
  rowsi, err := rowsiFromStatement(ctx, dc.ci, ds, args...)
  if err != nil {
      ds.Close()
      releaseConn(err)
      return nil, err
  }

  // Note: ownership of ci passes to the *Rows, to be freed
  // with releaseConn.
  rows := &amp;Rows{
      dc:          dc,
      releaseConn: releaseConn,
      rowsi:       rowsi,
      closeStmt:   ds,
  }
  rows.initContextClose(ctx, txctx)
  return rows, nil
</code></pre>

<p>  }
```</p>

<p>根据驱动或者用户配置不同，以上代码会有不同的执行路径，假设最终走直接查询的路径（即不走Prepared Statement），则会继续执行如下逻辑：</p>

<p>```go
// 执行到ctxDriverQuery函数</p>

<p>func ctxDriverQuery(ctx context.Context, queryerCtx driver.QueryerContext, queryer driver.Queryer, query string, nvdargs []driver.NamedValue) (driver.Rows, error) {</p>

<pre><code>if queryerCtx != nil {
    return queryerCtx.QueryContext(ctx, query, nvdargs)
}
dargs, err := namedValueToValue(nvdargs)
if err != nil {
    return nil, err
}

// 注意这里ctx的用法，根据ctx是否已被取消，提早返回 
select {
default:
case &lt;-ctx.Done():
    return nil, ctx.Err()
}
// 从这里以后就会到驱动的代码了
return queryer.Query(query, dargs)
</code></pre>

<p>}
```
如果使用的是mysql的驱动，会继续执行以下代码：</p>

<p>```go
  func (mc *mysqlConn) Query(query string, args []driver.Value) (driver.Rows, error) {</p>

<pre><code>  return mc.query(query, args)
</code></pre>

<p>  }</p>

<pre><code>func (mc *mysqlConn) query(query string, args []driver.Value) (*textRows, error) {
  if mc.closed.IsSet() {
      errLog.Print(ErrInvalidConn)
      return nil, driver.ErrBadConn
  }
  if len(args) != 0 {
      // 是否转义sql中的参数来防止sql注入
      // 如果指定不转义的话会使用 prepared statement
      if !mc.cfg.InterpolateParams {
          return nil, driver.ErrSkip
      }
      // try client-side prepare to reduce roundtrip
      prepared, err := mc.interpolateParams(query, args)
      if err != nil {
          return nil, err
      }
      query = prepared
  }
  // Send command
  err := mc.writeCommandPacketStr(comQuery, query)
  if err == nil {
      // Read Result
      var resLen int
      resLen, err = mc.readResultSetHeaderPacket()
      if err == nil {
          rows := new(textRows)
          rows.mc = mc

          if resLen == 0 {
              rows.rs.done = true

              switch err := rows.NextResultSet(); err {
              case nil, io.EOF:
                  return rows, nil
              default:
                  return nil, err
              }
          }

          // Columns
          rows.rs.columns, err = mc.readColumns(resLen)
          return rows, err
      }
  }
  return nil, mc.markBadConn(err)
</code></pre>

<p>  }
```
上面只是读出了“表头”，拿到了row对象，下面要开始读取具体的记录了（对应一开始的例子中的Scan语句）</p>

<p>对于只返回一行的query直接调用Scan就可以了(其实，在暗地里帮你调用了Next)，返回多行时需要先调用Next，然后再调用Scan</p>

<p>```go
  func (rs *Rows) Next() bool {</p>

<pre><code>  var doClose, ok bool
  withLock(rs.closemu.RLocker(), func() {
      doClose, ok = rs.nextLocked()
  })
  if doClose {
      rs.Close()
  }
  return ok
</code></pre>

<p>  }</p>

<p>  func (rs *Rows) nextLocked() (doClose, ok bool) {</p>

<pre><code>  if rs.closed {
      return false, false
  }

  // Lock the driver connection before calling the driver interface
  // rowsi to prevent a Tx from rolling back the connection at the same time.
  rs.dc.Lock()
  defer rs.dc.Unlock()

  if rs.lastcols == nil {
      rs.lastcols = make([]driver.Value, len(rs.rowsi.Columns()))
  }
  // 从此进入驱动的代码
  rs.lasterr = rs.rowsi.Next(rs.lastcols)
  if rs.lasterr != nil {
      // Close the connection if there is a driver error.
      if rs.lasterr != io.EOF {
          return true, false
      }
      nextResultSet, ok := rs.rowsi.(driver.RowsNextResultSet)
      if !ok {
          return true, false
      }
      // The driver is at the end of the current result set.
      // Test to see if there is another result set after the current one.
      // Only close Rows if there is no further result sets to read.
      if !nextResultSet.HasNextResultSet() {
          doClose = true
      }
      return doClose, false
  }
  return false, true
</code></pre>

<p>  }</p>

<p>  // mysql驱动的代码，位于rows.go中
  func (rows *textRows) Next(dest []driver.Value) error {</p>

<pre><code>if mc := rows.mc; mc != nil {
    if err := mc.error(); err != nil {
        return err
    }

    // Fetch next row from stream
    // 这里会读取MySQL的查询结果
    // 想了解MySQL的client与server间的交互协议的可以看这个函数
    return rows.readRow(dest)
}
return io.EOF
</code></pre>

<p>}
```</p>

<p>执行Next之后，会将从mysql读到的行数据保存在Rows对象的一个私有字段里(lastcols)，然后终于来到了Scan阶段</p>

<p>```go
  func (rs *Rows) Scan(dest &hellip;interface{}) error {</p>

<pre><code>  rs.closemu.RLock()

  if rs.lasterr != nil &amp;&amp; rs.lasterr != io.EOF {
      rs.closemu.RUnlock()
      return rs.lasterr
  }
  if rs.closed {
      err := rs.lasterrOrErrLocked(errRowsClosed)
      rs.closemu.RUnlock()
      return err
  }
  rs.closemu.RUnlock()

  if rs.lastcols == nil {
      return errors.New("sql: Scan called without calling Next")
  }
  if len(dest) != len(rs.lastcols) {
      return fmt.Errorf("sql: expected %d destination arguments in Scan, not %d", len(rs.lastcols), len(dest))
  }
  // 遍历这一行的每一个字段
  for i, sv := range rs.lastcols {
      // 转成Golang内部类型
      // 对于数据库里的某个字段类型会被转成Golang里哪种类型
      // 有疑问的可以看这个函数的实现
      err := convertAssignRows(dest[i], sv, rs)
      if err != nil {
          return fmt.Errorf(`sql: Scan error on column index %d, name %q: %v`, i, rs.rowsi.Columns()[i], err)
      }
  }
  return nil
</code></pre>

<p>  }
```</p>

<p>至此，一次完整的查询过程就分析完了。</p>

<p>下面想具体了解下<code>database/sql</code>包是如何维护数据库的连接池的。</p>

<blockquote><p>有兴趣的可以看一下Goang 从1.0到现在的1.12，<code>database/sql</code>包是如何演化的，如果你去看1.1的源码会发现那时候的连接池实现很简陋，那会儿的连接池没有最大连接数的限制</p></blockquote>

<p>这个连接池有几个特征参数：</p>

<ul>
<li>maxLifetime

<ul>
<li>maximum amount of time a connection may be reused</li>
</ul>
</li>
<li>maxIdle

<ul>
<li>允许的最大空闲连接数</li>
</ul>
</li>
<li>maxOpen

<ul>
<li>允许的打开的最大连接数</li>
</ul>
</li>
</ul>


<p>连接池中的连接数最大会增长到maxOpen，当请求高峰过后，连接池的可用连接数又会慢慢缩回到maxIdle</p>

<p>```go
  func (db <em>DB) Query(query string, args &hellip;interface{}) (</em>Rows, error) {</p>

<pre><code>  return db.QueryContext(context.Background(), query, args...)
</code></pre>

<p>  }</p>

<p>  func (db <em>DB) QueryContext(ctx context.Context, query string, args &hellip;interface{}) (</em>Rows, error) {</p>

<pre><code>  var rows *Rows
  var err error
  // 优先用池子里的连接
  for i := 0; i &lt; maxBadConnRetries; i++ {
      rows, err = db.query(ctx, query, args, cachedOrNewConn)
      if err != driver.ErrBadConn {
          break
      }
  }
  // 当然池子里的连接有可能会过期，如果重试两次还取不到可以用的连接
  // 那就从数据库请求一个新的
  if err == driver.ErrBadConn {
      return db.query(ctx, query, args, alwaysNewConn)
  }
  return rows, err
</code></pre>

<p>  }</p>

<pre><code>func (db *DB) query(ctx context.Context, query string, args []interface{}, strategy connReuseStrategy) (*Rows, error) {
  dc, err := db.conn(ctx, strategy)
  if err != nil {
      return nil, err
  }

  return db.queryDC(ctx, nil, dc, dc.releaseConn, query, args)
</code></pre>

<p>  }
```</p>

<p>下面就是获取连接的逻辑了，流程如下：</p>

<ul>
<li>如果策略是优先使用缓存连接且连接池中还有空闲连接，则直接从连接池中取一个连接返回</li>
<li>如果连接池里当前已打开的连接数已超出maxOpen限制，则阻塞一直等待有连接归还到连接池后再取用</li>
<li>否则就新建一个连接返回</li>
</ul>


<p>```go
  // conn returns a newly-opened or cached <em>driverConn.
  func (db </em>DB) conn(ctx context.Context, strategy connReuseStrategy) (*driverConn, error) {</p>

<pre><code>  db.mu.Lock()
  if db.closed {
      db.mu.Unlock()
      return nil, errDBClosed
  }
  // 检查是否已被取消
  // Check if the context is expired.
  select {
  default:
  case &lt;-ctx.Done():
      db.mu.Unlock()
      return nil, ctx.Err()
  }
  // 一个连接的最大生命周期
  lifetime := db.maxLifetime

  // Prefer a free connection, if possible.
  numFree := len(db.freeConn)
  if strategy == cachedOrNewConn &amp;&amp; numFree &gt; 0 {
      conn := db.freeConn[0]
      // copy(dst, src []Type) int
      // The copy built-in function copies elements from a source slice into a destination slice
      // The source and destination may overlap.
      // 这是在更新空闲的数据库连接数组，最开始的那个连接现在已经要被占用了
      copy(db.freeConn, db.freeConn[1:])
      // 移除掉末尾那个无用的元素
      db.freeConn = db.freeConn[:numFree-1]
      // 通过以上两步，成功从freeConn中删掉了开头的第一个连接
      conn.inUse = true
      db.mu.Unlock()
      // 检查连接是否已经过期
      // 注意如果过期并没有尝试取下一个，而是直接返回了错误
      // 由上层来继续发起连接，我理解这样会保持不同层之间逻辑的干净
      if conn.expired(lifetime) {
          conn.Close()
          return nil, driver.ErrBadConn
      }
      // Lock around reading lastErr to ensure the session resetter finished.
      // 这里应该是看下这个连接是不是被session resetter给置为badConn了
      // 如果是，那也不能用了
      // session resetter 是一个单独的goroutine在检查每个连接的状态
      conn.Lock()
      err := conn.lastErr
                conn.Unlock()
      if err == driver.ErrBadConn {
          conn.Close()
          return nil, driver.ErrBadConn
      }
      return conn, nil
  }

  // Out of free connections or we were asked not to use one. If we're not
  // allowed to open any more connections, make a request and wait.
  // 如果当前打开的连接数已经超过了db.maxOpen
  if db.maxOpen &gt; 0 &amp;&amp; db.numOpen &gt;= db.maxOpen {
      // Make the connRequest channel. It's buffered so that the
      // connectionOpener doesn't block while waiting for the req to be read.
      req := make(chan connRequest, 1)
      reqKey := db.nextRequestKeyLocked()
      db.connRequests[reqKey] = req
      db.waitCount++
      db.mu.Unlock()

      waitStart := time.Now()

      // Timeout the connection request with the context.
      select {
      // 注意这个select没有default分支，所以会一直阻塞在这两个分支上
      // 直到任何一个分支的条件满足，即：1. query被取消了 2. 有free连接可用了
      case &lt;-ctx.Done():
          // Remove the connection request and ensure no value has been sent
          // on it after removing.
          db.mu.Lock()
          delete(db.connRequests, reqKey)
          db.mu.Unlock()

          atomic.AddInt64(&amp;db.waitDuration, int64(time.Since(waitStart)))

          select {
          default:
          case ret, ok := &lt;-req:
              if ok &amp;&amp; ret.conn != nil {
                  db.putConn(ret.conn, ret.err, false)
              }
          }
          return nil, ctx.Err()
      case ret, ok := &lt;-req:
          atomic.AddInt64(&amp;db.waitDuration, int64(time.Since(waitStart)))

          if !ok {
              return nil, errDBClosed
          }
          if ret.err == nil &amp;&amp; ret.conn.expired(lifetime) {
              ret.conn.Close()
              return nil, driver.ErrBadConn
          }
          if ret.conn == nil {
              return nil, ret.err
          }
          // Lock around reading lastErr to ensure the session resetter finished.
          ret.conn.Lock()
          err := ret.conn.lastErr
          ret.conn.Unlock()
          if err == driver.ErrBadConn {
              ret.conn.Close()
              return nil, driver.ErrBadConn
          }
          return ret.conn, ret.err
      }
  }
  // 如果没有空闲连接且尚未达到最大连接数的限制
  // 那就开一个新连接
  db.numOpen++ // optimistically
  db.mu.Unlock()
  ci, err := db.connector.Connect(ctx)
  if err != nil {
      db.mu.Lock()
      db.numOpen-- // correct for earlier optimism
      db.maybeOpenNewConnections()
      db.mu.Unlock()
      return nil, err
  }
  db.mu.Lock()
  dc := &amp;driverConn{
      db:        db,
      createdAt: nowFunc(),
      ci:        ci,
      inUse:     true,
  }
  db.addDepLocked(dc, dc)
  db.mu.Unlock()
  return dc, nil
</code></pre>

<p>  }
```</p>

<p>有借就有还，再借才不难，下面是归还连接的逻辑：</p>

<ul>
<li>如果有connRequests，那么优先满足它</li>
<li>否则就要准备归还到池子中了，但这里还有一个check，如果当前空闲连接书freeConn大于允许的最大空闲连接限制的话就不归还了，会把连接直接关闭掉</li>
</ul>


<p>```go
  // putConn adds a connection to the db&rsquo;s free pool.
  // err is optionally the last error that occurred on this connection.
  func (db <em>DB) putConn(dc </em>driverConn, err error, resetSession bool) {</p>

<pre><code>  db.mu.Lock()
  if !dc.inUse {
      if debugGetPut {
          fmt.Printf("putConn(%v) DUPLICATE was: %s\n\nPREVIOUS was: %s", dc, stack(), db.lastPut[dc])
      }
      panic("sql: connection returned that was never out")
  }
  if debugGetPut {
      db.lastPut[dc] = stack()
  }
  dc.inUse = false

  for _, fn := range dc.onPut {
      fn()
  }
  dc.onPut = nil

  if err == driver.ErrBadConn {
      // Don't reuse bad connections.
      // Since the conn is considered bad and is being discarded, treat it
      // as closed. Don't decrement the open count here, finalClose will
      // take care of that.
      db.maybeOpenNewConnections()
      db.mu.Unlock()
      dc.Close()
      return
  }
  if putConnHook != nil {
      putConnHook(db, dc)
  }
  if db.closed {
      // Connections do not need to be reset if they will be closed.
      // Prevents writing to resetterCh after the DB has closed.
      resetSession = false
  }
  if resetSession {
      if _, resetSession = dc.ci.(driver.SessionResetter); resetSession {
          // Lock the driverConn here so it isn't released until
          // the connection is reset.
          // The lock must be taken before the connection is put into
          // the pool to prevent it from being taken out before it is reset.
          dc.Lock()
      }
  }
  added := db.putConnDBLocked(dc, nil)
  db.mu.Unlock()

  if !added {
      if resetSession {
          dc.Unlock()
      }
      dc.Close()
      return
  }
  if !resetSession {
      return
  }
  select {
  default:
      // If the resetterCh is blocking then mark the connection
      // as bad and continue on.
      dc.lastErr = driver.ErrBadConn
      dc.Unlock()
  case db.resetterCh &lt;- dc:
  }
</code></pre>

<p>  }</p>

<pre><code>func (db *DB) putConnDBLocked(dc *driverConn, err error) bool {
  if db.closed {
      return false
  }
  if db.maxOpen &gt; 0 &amp;&amp; db.numOpen &gt; db.maxOpen {
      return false
  }
  // 如果有connRequests（连接需求），优先满足它
  if c := len(db.connRequests); c &gt; 0 {
      var req chan connRequest
      var reqKey uint64
      for reqKey, req = range db.connRequests {
          break
      }
      delete(db.connRequests, reqKey) // Remove from pending requests.
      if err == nil {
          dc.inUse = true
      }
      req &lt;- connRequest{
          conn: dc,
          err:  err,
      }
      return true
  } else if err == nil &amp;&amp; !db.closed {
      if db.maxIdleConnsLocked() &gt; len(db.freeConn) {
          // 将连接放回池子
          db.freeConn = append(db.freeConn, dc)
          db.startCleanerLocked()
          return true
      }
      // 为啥直接增加了maxIdleClosed而没有做什么呢？
      // 因为这种情况下本函数会返回false，进而导致
      // 连接被关闭
      db.maxIdleClosed++
  }
  return false
</code></pre>

<p>  }
```</p>

<p>以下逻辑实现连接的生命周期的管理，基本逻辑为：</p>

<p>定期遍历连接池中的每一个连接，检查其是存活时间是否超出了设定的maxLifetime，若超出则将它从池子中删除并关闭它</p>

<p>```go
  // startCleanerLocked starts connectionCleaner if needed.
  func (db *DB) startCleanerLocked() {</p>

<pre><code>  // 尽管每次putConnDBLocked的时候都会被调用，但注意它的条件db.cleanerCh == nil
  // 这意味着其实db.connectionCleaner只会被启动一次
  if db.maxLifetime &gt; 0 &amp;&amp; db.numOpen &gt; 0 &amp;&amp; db.cleanerCh == nil {
      db.cleanerCh = make(chan struct{}, 1)
      go db.connectionCleaner(db.maxLifetime)
  }
</code></pre>

<p>  }
   // 清理过期连接的逻辑
   func (db *DB) connectionCleaner(d time.Duration) {</p>

<pre><code>  const minInterval = time.Second
  // 精度最高为秒级
  if d &lt; minInterval {
      d = minInterval
  }
  t := time.NewTimer(d)

  for {
      // 这个写法很有意思
      select {
      case &lt;-t.C:
      case &lt;-db.cleanerCh: // maxLifetime was changed or db was closed.
      }

      db.mu.Lock()
      d = db.maxLifetime
      if db.closed || db.numOpen == 0 || d &lt;= 0 {
          db.cleanerCh = nil
          db.mu.Unlock()
          return
      }

      expiredSince := nowFunc().Add(-d)
      var closing []*driverConn
      for i := 0; i &lt; len(db.freeConn); i++ {
          c := db.freeConn[i]
          if c.createdAt.Before(expiredSince) {
              closing = append(closing, c)
              last := len(db.freeConn) - 1
              // 数组中经典的删除元素的方法
              db.freeConn[i] = db.freeConn[last]
              db.freeConn[last] = nil
              db.freeConn = db.freeConn[:last]
              // 后退一步是为了可以检查刚刚置换过来的元素
              i--
          }
      }
      db.maxLifetimeClosed += int64(len(closing))
      db.mu.Unlock()

      for _, c := range closing {
          c.Close()
      }

      if d &lt; minInterval {
          d = minInterval
      }
      t.Reset(d)
    }
</code></pre>

<p>  }
```</p>

<h3>Prepared Statement</h3>

<p>根据MySQL<a href="https://dev.mysql.com/doc/refman/5.7/en/sql-syntax-prepared-statements.html">文档</a>，prepared statement 只能绑定在一个连接（session）上，即如果在一个连接上执行了prepare后，后续的exec还是要在同一个连接上才行，以下引自MySQL文档：</p>

<blockquote><p>A prepared statement is specific to the session in which it was created. If you terminate a session without deallocating a previously prepared statement, the server deallocates it automatically.</p></blockquote>

<p>但在Golang的<code>database/sql</code>包中，连接并没有直接暴露给开发者（从1.9以后暴露了一个单独的连接对象Conn），开发者看到的是一个连接池，那么<code>database/sql</code>是如何在只暴露连接池的情况下来支持prepared statement的呢？</p>

<p>是这么做的：</p>

<ol>
<li>Prepare的阶段从连接池中取出一个连接来发起prepare的操作，执行完后就把连接放回连接池了，但此时要记住是在这个连接上发起了Prepare</li>
<li>在execute阶段，会从连接池中需要当时发起prepare的那个连接，找到后再继续发起execute操作即可。但这里就有个问题，这时候可能找不到当时那个连接了（要么这个连接正在被别人占用，要么这个连接已经被关闭了），那么此时就需要从池子中再取一个连接出来，重新发起prepare。

<ul>
<li>这里有个坑：在高并发的情况下，会在服务端创建大量重复的prepared statement，可能会耗尽服务端的最大prepared statement限制</li>
</ul>
</li>
</ol>


<p>参考：<a href="http://go-database-sql.org/prepared.html">Using Prepared Statements</a></p>

<p>下面从代码上具体分析一下：</p>

<p>首先是数据结构：</p>

<p>```go
  // Stmt is a prepared statement.
  // A Stmt is safe for concurrent use by multiple goroutines.
  //
  // If a Stmt is prepared on a Tx or Conn, it will be bound to a single
  // underlying connection forever. If the Tx or Conn closes, the Stmt will
  // become unusable and all operations will return an error.
  // If a Stmt is prepared on a DB, it will remain usable for the lifetime of the
  // DB. When the Stmt needs to execute on a new underlying connection, it will
  // prepare itself on the new connection automatically.
  type Stmt struct {</p>

<pre><code>  // Immutable:
  db        *DB    // where we came from
  query     string // that created the Stmt
  stickyErr error  // if non-nil, this error is returned for all operations

  closemu sync.RWMutex // held exclusively during close, for read otherwise.

  // If Stmt is prepared on a Tx or Conn then cg is present and will
  // only ever grab a connection from cg.
  // If cg is nil then the Stmt must grab an arbitrary connection
  // from db and determine if it must prepare the stmt again by
  // inspecting css.
  cg   stmtConnGrabber
  cgds *driverStmt

  // parentStmt is set when a transaction-specific statement
  // is requested from an identical statement prepared on the same
  // conn. parentStmt is used to track the dependency of this statement
  // on its originating ("parent") statement so that parentStmt may
  // be closed by the user without them having to know whether or not
  // any transactions are still using it.
  parentStmt *Stmt

  mu     sync.Mutex // protects the rest of the fields
  closed bool

  // css is a list of underlying driver statement interfaces
  // that are valid on particular connections. This is only
  // used if cg == nil and one is found that has idle
  // connections. If cg != nil, cgds is always used.
  css []connStmt

  // lastNumClosed is copied from db.numClosed when Stmt is created
  // without tx and closed connections in css are removed.
  lastNumClosed uint64
</code></pre>

<p>  }
```</p>

<p>prepare阶段，分别可以从DB、Conn和Tx上发起Prepare，先分析在DB上的Prepare</p>

<p>```go
  func (db <em>DB) PrepareContext(ctx context.Context, query string) (</em>Stmt, error) {</p>

<pre><code>  var stmt *Stmt
  var err error
  for i := 0; i &lt; maxBadConnRetries; i++ {
      stmt, err = db.prepare(ctx, query, cachedOrNewConn)
      if err != driver.ErrBadConn {
          break
      }
  }
  if err == driver.ErrBadConn {
      return db.prepare(ctx, query, alwaysNewConn)
  }
  return stmt, err
</code></pre>

<p>  }</p>

<pre><code>func (db *DB) prepare(ctx context.Context, query string, strategy connReuseStrategy) (*Stmt, error) {
  // TODO: check if db.driver supports an optional
  // driver.Preparer interface and call that instead, if so,
  // otherwise we make a prepared statement that's bound
  // to a connection, and to execute this prepared statement
  // we either need to use this connection (if it's free), else
  // get a new connection + re-prepare + execute on that one.
  // 先从池子中获取一个连接
  dc, err := db.conn(ctx, strategy)
  if err != nil {
      return nil, err
  }
  return db.prepareDC(ctx, dc, dc.releaseConn, nil, query)
</code></pre>

<p>  }</p>

<pre><code>func (db *DB) prepareDC(ctx context.Context, dc *driverConn, release func(error), cg stmtConnGrabber, query string) (*Stmt, error) {
  var ds *driverStmt
  var err error
  defer func() {
      release(err)
  }()
  // 这里是调用驱动来向server发起Prepare命令
  withLock(dc, func() {
      ds, err = dc.prepareLocked(ctx, cg, query)
  })
  if err != nil {
      return nil, err
  }
  stmt := &amp;Stmt{
      db:    db,
      query: query,
      cg:    cg,
      cgds:  ds,
  }

  // When cg == nil this statement will need to keep track of various
  // connections they are prepared on and record the stmt dependency on
  // the DB.
  // 记住这个stmt是在哪个conn上Prepare的，便于后续exec时再继续用
  if cg == nil {
      stmt.css = []connStmt
      stmt.lastNumClosed = atomic.LoadUint64(&amp;db.numClosed)
      db.addDep(stmt, stmt)
  }
  return stmt, nil
</code></pre>

<p>  }
```</p>

<p>执行阶段</p>

<p>```go
  func (s *Stmt) ExecContext(ctx context.Context, args &hellip;interface{}) (Result, error) {</p>

<pre><code>  s.closemu.RLock()
  defer s.closemu.RUnlock()

  var res Result
  strategy := cachedOrNewConn
  for i := 0; i &lt; maxBadConnRetries+1; i++ {
      if i == maxBadConnRetries {
          strategy = alwaysNewConn
      }
      // 这里是尝试取回当时进行Prepare的连接以待继续操作
      dc, releaseConn, ds, err := s.connStmt(ctx, strategy)
      if err != nil {
          if err == driver.ErrBadConn {
              continue
          }
          return nil, err
      }
      // 从驱动读取执行结果
      res, err = resultFromStatement(ctx, dc.ci, ds, args...)
      releaseConn(err)
      if err != driver.ErrBadConn {
          return res, err
      }
  }
  return nil, driver.ErrBadConn
</code></pre>

<p>  }</p>

<pre><code>func (s *Stmt) connStmt(ctx context.Context, strategy connReuseStrategy) (dc *driverConn, releaseConn func(error), ds *driverStmt, err error) {
  if err = s.stickyErr; err != nil {
      return
  }
  s.mu.Lock()
  if s.closed {
      s.mu.Unlock()
      err = errors.New("sql: statement is closed")
      return
  }

  // In a transaction or connection, we always use the connection that the
  // stmt was created on.
  // 在Tx或者Conn上Prepare的情况
  if s.cg != nil {
      s.mu.Unlock()
      dc, releaseConn, err = s.cg.grabConn(ctx) // blocks, waiting for the connection.
      if err != nil {
          return
      }
      return dc, releaseConn, s.cgds, nil
  }

  s.removeClosedStmtLocked()
  s.mu.Unlock()
  // 以下是在DB上Prepare时的处理逻辑
  // 简单粗暴，直接从池子里取一个连接，
  // 然后判断这个连接是不是之前prepare过，
  // 若prepare过，则直接返回这个连接即可，
  // 若没有，则直接在这个连接上重新prepare后再返回
  dc, err = s.db.conn(ctx, strategy)
  if err != nil {
      return nil, nil, nil, err
  }

  s.mu.Lock()
  for _, v := range s.css {
      if v.dc == dc {
          s.mu.Unlock()
          return dc, dc.releaseConn, v.ds, nil
      }
  }
  s.mu.Unlock()

  // No luck; we need to prepare the statement on this connection
  withLock(dc, func() {
      ds, err = s.prepareOnConnLocked(ctx, dc)
  })
  if err != nil {
      dc.releaseConn(err)
      return nil, nil, nil, err
  }

  return dc, dc.releaseConn, ds, nil
</code></pre>

<p>  }
```</p>

<p>这里有个小插曲，在对照源码的各个版本的<code>database/sql</code>包的实现时，偶然发现connStmt方法的实现经历了不少的改变呢，想知道这改变背后的原因，于是对提交历史考据了一番，还真找到了：</p>

<p>相关的commit: 1b61a97811626d4c7a8332c107f1e091253d1b2e</p>

<p>对应的github issue: <a href="https://github.com/golang/go/issues/9484">https://github.com/golang/go/issues/9484</a></p>

<p>一开始的实现，相对精细，导致锁冲突有点严重，后来又改成简单粗暴了，同时也减少了锁冲突，提高了性能，但高并发时会有很多重新Prepare的情况。</p>

<p>关闭阶段</p>

<p>```go
  // Close closes the statement.
  func (s *Stmt) Close() error {</p>

<pre><code>  s.closemu.Lock()
  defer s.closemu.Unlock()

  if s.stickyErr != nil {
      return s.stickyErr
  }
  s.mu.Lock()
  if s.closed {
      s.mu.Unlock()
      return nil
  }
  s.closed = true
  txds := s.cgds
  s.cgds = nil

  s.mu.Unlock()

  if s.cg == nil {
      return s.db.removeDep(s, s)
  }

  if s.parentStmt != nil {
      // If parentStmt is set, we must not close s.txds since it's stored
      // in the css array of the parentStmt.
      return s.db.removeDep(s.parentStmt, s)
  }
  // txds是驱动端的stmt，最终调了驱动端的Close来关闭
  return txds.Close()
</code></pre>

<p>  }
```</p>

<p>参考：</p>

<ul>
<li><a href="https://www.jianshu.com/p/ee0d2e7bef54">Prepared剖析</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/sql-syntax-prepared-statements.html">Prepared SQL Statement </a></li>
<li><a href="http://go-database-sql.org/prepared.html">Using Prepared Statements</a></li>
</ul>


<h3>Tx</h3>

<p>下面分析下对数据库事务的支持。同prepared statement一样，在数据库层面事务也只能在一个连接上进行，但在底层实现上，Tx的实现与prepared statement有明显不同，它底层从始至终只使用了一个连接。不过，我不太明白prepared statement为啥没有这样实现。</p>

<p>开启事务</p>

<p>```go
  func (db <em>DB) BeginTx(ctx context.Context, opts </em>TxOptions) (*Tx, error) {</p>

<pre><code>  var tx *Tx
  var err error
  for i := 0; i &lt; maxBadConnRetries; i++ {
      tx, err = db.begin(ctx, opts, cachedOrNewConn)
      if err != driver.ErrBadConn {
          break
      }
  }
  if err == driver.ErrBadConn {
      return db.begin(ctx, opts, alwaysNewConn)
  }
  return tx, err
</code></pre>

<p>  }</p>

<pre><code>func (db *DB) begin(ctx context.Context, opts *TxOptions, strategy connReuseStrategy) (tx *Tx, err error) {
  // 依然是先从池子中取出一个空闲连接
  dc, err := db.conn(ctx, strategy)
  if err != nil {
      return nil, err
  }
  return db.beginDC(ctx, dc, dc.releaseConn, opts)
</code></pre>

<p>  }</p>

<pre><code>func (db *DB) beginDC(ctx context.Context, dc *driverConn, release func(error), opts *TxOptions) (tx *Tx, err error) {
  var txi driver.Tx
  withLock(dc, func() {
      // 调用driver来开启事务
      txi, err = ctxDriverBegin(ctx, opts, dc.ci)
  })
  if err != nil {
      release(err)
      return nil, err
  }

  // Schedule the transaction to rollback when the context is cancelled.
  // The cancel function in Tx will be called after done is set to true.
  ctx, cancel := context.WithCancel(ctx)
  // 注意返回的tx对象记了启动事务的连接dc
  // 后续所有的操作都会在这一个dc上进行
  tx = &amp;Tx{
      db:          db,
      dc:          dc,
      releaseConn: release,
      txi:         txi,
      cancel:      cancel,
      ctx:         ctx,
  }
  go tx.awaitDone()
  return tx, nil
</code></pre>

<p>  }
```</p>

<p>执行阶段，exec和query过程类似，下面只分析exec的过程</p>

<p>```go
  func (tx <em>Tx) QueryContext(ctx context.Context, query string, args &hellip;interface{}) (</em>Rows, error) {</p>

<pre><code>  // 取出之前保存在tx上的连接dc
  dc, release, err := tx.grabConn(ctx)
  if err != nil {
      return nil, err
  }
  // 其实就是db.queryDC的逻辑
  // 现在知道为什么tx上要记一个db对象了
  return tx.db.queryDC(ctx, tx.ctx, dc, release, query, args)
</code></pre>

<p>  }</p>

<pre><code>func (tx *Tx) grabConn(ctx context.Context) (*driverConn, releaseConn, error) {
  select {
  default:
  case &lt;-ctx.Done():
      return nil, nil, ctx.Err()
  }

  // closeme.RLock must come before the check for isDone to prevent the Tx from
  // closing while a query is executing.
  // 这个读写锁的目的是保证当tx被关闭时已经没有任何其它的查询在进行了
  // 注意到一般每一个资源对象都有这样一个锁，比如Row、Stmt
  tx.closemu.RLock()
  if tx.isDone() {
      tx.closemu.RUnlock()
      return nil, nil, ErrTxDone
  }
  if hookTxGrabConn != nil { // test hook
      hookTxGrabConn()
  }
  // 返回的是tx上记的那个dc
  return tx.dc, tx.closemuRUnlockRelease, nil
</code></pre>

<p>  }
```</p>

<h3>参考</h3>

<ul>
<li><a href="https://chenjiayang.me/2019/08/10/go-sql-database-pool/">借 Go 语言 database/sql 包谈数据库驱动和连接池设计</a></li>
<li><a href="http://luodw.cc/2016/08/28/golang02/">golang之database/sql与go-sql-driver</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[job queue in Golang]]></title>
    <link href="http://cs50Mu.github.io/blog/2019/07/20/job-queue-in-golang/"/>
    <updated>2019-07-20T12:16:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2019/07/20/job-queue-in-golang</id>
    <content type="html"><![CDATA[<p>异步任务，还是蛮常见的</p>

<h3>算不上 job queue的形式</h3>

<p><code>go process(job)</code></p>

<p>这其实算不上一个queue，但简单。同时，少了一些对并发的控制，比如控制同时执行的任务数等。</p>

<h3>最简单的 job queue</h3>

<p>```go
func worker(jobChan &lt;-chan Job) {</p>

<pre><code>for job := range jobChan {
    process(job)
}
</code></pre>

<p>}</p>

<p>// make a channel with a capacity of 100.
jobChan := make(chan Job, 100)</p>

<p>// start the worker
go worker(jobChan)</p>

<p>// enqueue a job
jobChan &lt;&ndash; job
```
注释已经很清楚了，通过向channel发消息来提交任务，worker 从 channel 中取任务做。注意 jobChan 是一个固定长度的 channel，这能够实现 producer throtting，当 queue 中已经有100个 task 时，此时的 enqueue 操作会阻塞。</p>

<h3>非阻塞式 enqueue</h3>

<p>如果 enqueue 时不想阻塞呢？比如我想如果队列满了，就直接给 client 端返回失败，告诉它等会再试试。可以这样：</p>

<p>```go
// TryEnqueue tries to enqueue a job to the given job channel. Returns true if
// the operation was successful, and false if enqueuing would not have been
// possible without blocking. Job is not enqueued in the latter case.
func TryEnqueue(job Job, jobChan &lt;-chan Job) bool {</p>

<pre><code>select {
case jobChan &lt;- job:
    return true
default:
    return false
}
</code></pre>

<p>}</p>

<p>// then you can do this
if !TryEnqueue(job, chan) {</p>

<pre><code>http.Error(w, "max capacity reached", 503)
return
</code></pre>

<p>}
```</p>

<h3>停止 worker</h3>

<p>如果没有任务需要做了，那么可以：</p>

<p><code>close(jobChan)</code></p>

<p>因为 worker 是通过<code>for job := range jobChan {...}</code> 这种形式来取任务的，当 channel 被关闭后，for loop 会停止循环，继而结束 worker。</p>

<p>需要注意的是：即使 channel 被 close 的时候，channel 里还有尚未被消费的 task，这些 task 照样会被正常消费完</p>

<h3>等待 worker 退出</h3>

<p><code>close</code> channel 只会通知 worker 当前已无更多任务，但并不会等待 worker 把任务做完，所以我们需要一种等待 worker 的机制：</p>

<p>```go
// use a WaitGroup
var wg sync.WaitGroup</p>

<p>func worker(jobChan &lt;-chan Job) {</p>

<pre><code>defer wg.Done()

for job := range jobChan {
    process(job)
}
</code></pre>

<p>}</p>

<p>// increment the WaitGroup before starting the worker
wg.Add(1)
go worker(jobChan)</p>

<p>// to stop the worker, first close the job channel
close(jobChan)</p>

<p>// then wait using the WaitGroup
wg.Wait()
```</p>

<h3>带超时时间的等待</h3>

<p>如果 worker 的任务一直没有做完，那么<code>wg.Wait()</code> 会无休止的等待下去，如果我们无法承受一直等待怎么办呢？</p>

<p>可以把<code>wg.Wait()</code>封装一下，给它增加 <code>timeout</code> 的功能</p>

<p>```go
// WaitTimeout does a Wait on a sync.WaitGroup object but with a specified
// timeout. Returns true if the wait completed without timing out, false
// otherwise.
func WaitTimeout(wg *sync.WaitGroup, timeout time.Duration) bool {</p>

<pre><code>ch := make(chan struct{})
go func() {
    wg.Wait()
    close(ch)
}()
select {
case &lt;-ch:
        return true
case &lt;-time.After(timeout):
        return false
}
</code></pre>

<p>}</p>

<p>// now use the WaitTimeout instead of wg.Wait()
WaitTimeout(&amp;wg, 5 * time.Second)
```</p>

<h3>取消 worker</h3>

<p>上面的代码中，如果我们发出退出的信号，worker 们会做完当前正在做的任务然后再退出，如果我们想让它立即退出该怎么办呢？</p>

<p>可以利用<code>context.Context</code></p>

<p>```go
// create a context that can be cancelled
ctx, cancel := context.WithCancel(context.Background())</p>

<p>// start the goroutine passing it the context
go worker(ctx, jobChan)</p>

<p>func worker(ctx context.Context, jobChan &lt;-chan Job) {</p>

<pre><code>for {
    select {
    case &lt;-ctx.Done():
        return

    case job := &lt;-jobChan:
        process(job)
    }
}
</code></pre>

<p>}</p>

<p>// Invoke cancel when the worker needs to be stopped. This <em>does not</em> wait
// for the worker to exit.
cancel()
```</p>

<p>但这里有一个小坑，当在收到退出信号时，同时也有job可取，那么 select 会<strong>随机</strong>选择一个路径来执行，并不会优先现在退出的路径，如果你想优先退出的话，需要这样：</p>

<p>```go
var flag uint64</p>

<p>func worker(ctx context.Context, jobChan &lt;-chan Job) {</p>

<pre><code>for {
    select {
    case &lt;-ctx.Done():
        return

    case job := &lt;-jobChan:
        process(job)
        if atomic.LoadUint64(&amp;flag) == 1 {
            return
        }
    }
}
</code></pre>

<p>}</p>

<p>// set the flag first, before cancelling
atomic.StoreUint64(&amp;flag, 1)
cancel()
```</p>

<p>或者这样：</p>

<p>```go
func worker(ctx context.Context, jobChan &lt;-chan Job) {</p>

<pre><code>for {
    select {
    case &lt;-ctx.Done():
        return

    case job := &lt;-jobChan:
        process(job)
        if ctx.Err() != nil {
            return
        }
    }
}
</code></pre>

<p>}</p>

<p>cancel()
```
(译者注：我觉得这样仍然不能保证退出路径优先被执行呀）</p>

<h3>不用 context 也能取消 worker</h3>

<p>如下，在某些场景下可能写法还更简洁，当然原理是一样的</p>

<p>```go
// create a cancel channel
cancelChan := make(chan struct{})</p>

<p>// start the goroutine passing it the cancel channel
go worker(jobChan, cancelChan)</p>

<p>func worker(jobChan &lt;-chan Job, cancelChan &lt;-chan struct{}) {</p>

<pre><code>for {
    select {
    case &lt;-cancelChan:
        return

    case job := &lt;-jobChan:
        process(job)
    }
}
</code></pre>

<p>}</p>

<p>// to cancel the worker, close the cancel channel
close(cancelChan)
```</p>

<h3>worker 池</h3>

<p>最简单的就是启动多个 worker，让它们读取同一个 channel</p>

<p>```go
for i:=0; i&lt;workerCount; i++ {</p>

<pre><code>go worker(jobChan)
</code></pre>

<p>}
```</p>

<p>如果想要等待 worker 退出</p>

<p>```go
for i:=0; i&lt;workerCount; i++ {</p>

<pre><code>wg.Add(1)
go worker(jobChan)
</code></pre>

<p>}</p>

<p>// wait for all workers to exit
wg.Wait()
```</p>

<p>取消 worker</p>

<p>```go
// create cancel channel
cancelChan := make(chan struct{})</p>

<p>// pass the channel to the workers, let them wait on it
for i:=0; i&lt;workerCount; i++ {</p>

<pre><code>go worker(jobChan, cancelChan)
</code></pre>

<p>}</p>

<p>// close the channel to signal the workers
close(cancelChan)
```</p>

<h3>参考</h3>

<ul>
<li><a href="https://disqus.com/embed/comments/?base=default&amp;f=opsdash&amp;t_u=https%3A%2F%2Fwww.opsdash.com%2Fblog%2Fjob-queues-in-go.html&amp;t_d=Job%20Queues%20in%20Go%20-%20OpsDash&amp;t_t=Job%20Queues%20in%20Go%20-%20OpsDash&amp;s_o=default#version=5c281b90be9cbae86fbebcbaed6c8c9b">JOB QUEUES IN GO</a></li>
<li><a href="https://gist.github.com/harlow/dbcd639cf8d396a2ab73">Golang Workers / Job Queue</a></li>
<li><a href="http://nesv.github.io/golang/2014/02/25/worker-queues-in-go.html">Writing worker queues, in Go</a></li>
<li><a href="http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang/">Handling 1 Million Requests per Minute with Go</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 中的文字编码问题]]></title>
    <link href="http://cs50Mu.github.io/blog/2019/05/19/a-encoding-problem-in-golang/"/>
    <updated>2019-05-19T22:41:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2019/05/19/a-encoding-problem-in-golang</id>
    <content type="html"><![CDATA[<h3>过程描述</h3>

<p>记录一个文字编码的问题</p>

<p>在请求支付宝支付的接口时，发现返回的Response如果有中文的话，print出来后会有乱码。第一反应肯定是编码有问题，那就先转一下编码吧。</p>

<p>一开始的代码大概如下：</p>

<p>```go</p>

<pre><code>resp, err := client.Post(aliPayBillURL, "application/x-www-form-urlencoded", bytes.NewBufferString(output))
if err != nil {
    panic(err)
}
defer resp.Body.Close()
body, err := ioutil.ReadAll(resp.Body)
if err != nil {
    panic(err)
}
//...
err = json.Unmarshal(body, &amp;queryResp)
if err != nil {
    panic(err)
}
data := queryResp.Data
// data.SubMsg里含有中文，会乱码
if data.Code != "10000" {
    fmt.Printf("download failed: msg: %s, sub_code: %s, sub_msg: %s\n", data.Msg, data.SubCode, data.SubMsg)
    panic("download failed")
} 
</code></pre>

<p>```</p>

<p>改为了：</p>

<p>```go</p>

<pre><code>resp, err := client.Post(aliPayBillURL, "application/x-www-form-urlencoded", bytes.NewBufferString(output))
if err != nil {
    panic(err)
}
defer resp.Body.Close()
body, err := ioutil.ReadAll(resp.Body)
if err != nil {
    panic(err)
}
//...
err = json.Unmarshal(body, &amp;queryResp)
if err != nil {
    panic(err)
}
data := queryResp.Data
converted, err := gbkToUtf8([]byte(data.SubMsg))
if err != nil {
    panic(err)
}
if data.Code != "10000" {
    fmt.Printf("download failed: msg: %s, sub_code: %s, sub_msg: %s\n", data.Msg, data.SubCode, converted)
    panic("download failed")
}
</code></pre>

<p>```</p>

<p>结果是依旧乱码。。难道不是编码的问题？</p>

<p>改<code>%s</code>为<code>%x</code>看看具体字节：</p>

<p>```go</p>

<pre><code>if data.Code != "10000" {
    fmt.Printf("download failed: msg: %s, sub_code: %s, sub_msg: %x\n", data.Msg, data.SubCode, converted)
    panic("download failed")
}
</code></pre>

<p>```</p>

<p>然后看到了这个<code>efbfbdefbfbdd0a7efbfbdefbfbd 4170704944 efbfbdefbfbdefbfbd</code>，之所以分成了三段贴出来，是因为我发现中间那段对应了部分正常显示的字符“Appid”，然后尝试手动解码一下其它两段，不管是GBK还是utf8都没有找到对应的字符。</p>

<p>然后发现第一段和最后一段的模式有点类似啊，都是<code>efbfbd</code>啥的，有点奇怪。尝试直接搜索<code>efbfbd</code>，定位到一篇<a href="https://liudanking.com/golang/utf-8_replacement_character/">文章</a>，里面主要讲到两点：</p>

<ul>
<li>这个序列就是utf8编码的，但它比较特殊，它是专门用来替换那些在解码时不认识的码点的，显示出来就是「�」</li>
<li>某些语言，比如 Goang，会自动进行这个转换，不会报错</li>
</ul>


<p>借用一下原文的例子：</p>

<p><code>go
now := time.Now().Unix() // 一个无效的码点值
str := string(now) // golang是utf-8编码，会对无效码点进行替换
fmt.Printf("%X", []byte(str)) // EFBFBD，即字符「�」
</code></p>

<p>这一下坚定了认为是编码的问题，那就是转码出问题了，再一看，我是在json decode之后再转码的，json decode的时候可能已经把数据按utf8解码了，而数据如果不是utf8编码的话，那就都被替换成<code>efbfbd</code>了，改为在json decode之前就转码试试：</p>

<p>```go</p>

<pre><code>resp, err := client.Post(aliPayBillURL, "application/x-www-form-urlencoded", bytes.NewBufferString(output))
if err != nil {
    panic(err)
}
defer resp.Body.Close()
body, err := ioutil.ReadAll(resp.Body)
if err != nil {
    panic(err)
}
converted, err := gbkToUtf8([]byte(body))
if err != nil {
    panic(err)
}
fmt.Println(string(converted))
err = json.Unmarshal(converted, &amp;queryResp)
if err != nil {
    panic(err)
}
data := queryResp.Data
if data.Code != "10000" {
    fmt.Printf("download failed: msg: %s, sub_code: %s, sub_msg: %s\n", data.Msg, data.SubCode, data.SubMsg)
    panic("download failed")
}
</code></pre>

<p>```</p>

<p>这次没问题了。</p>

<h3>反思 &amp;&amp; 教训</h3>

<ul>
<li>获取到数据后不要做任何操作，先做转码</li>
<li>记住<code>efbfbd</code>，它是一个信号，说明源数据一定不是utf8编码的</li>
</ul>


<p>最后，记录一下 Golang 中如何从 GBK 转为 utf8</p>

<p>```go
import (
golang.org/x/text/encoding/simplifiedchinese
golang.org/x/text/transform
)</p>

<p>func gbkToUtf8(s []byte) ([]byte, error) {</p>

<pre><code>reader := transform.NewReader(bytes.NewReader(s), simplifiedchinese.GBK.NewDecoder())
d, err := ioutil.ReadAll(reader)
if err != nil {
    return nil, err
}
return d, nil
</code></pre>

<p>}
```</p>

<h3>参考</h3>

<ul>
<li><a href="https://liudanking.com/golang/utf-8_replacement_character/">你应该记住的一个UTF-8字符「EF BF BD」</a></li>
<li><a href="http://mengqi.info/html/2015/201507071345-using-golang-to-convert-text-between-gbk-and-utf-8.html">Golang 中的 UTF-8 与 GBK 编码转换</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[database with sqlx in Golang]]></title>
    <link href="http://cs50Mu.github.io/blog/2019/05/09/database-with-sqlx-in-golang/"/>
    <updated>2019-05-09T10:39:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2019/05/09/database-with-sqlx-in-golang</id>
    <content type="html"><![CDATA[<h2>database with sqlx in Golang</h2>

<h3>Parameterized Queries</h3>

<p>翻译为参数化查询？是个什么概念呢？</p>

<p>Bind parameters—also called dynamic parameters or bind variables—are an alternative way to pass data to the database. Instead of putting the values directly into the SQL statement, you just use a placeholder like ?, :name or @name and provide the actual values using a separate API call.</p>

<p>原来说的是这种形式：</p>

<p><code>go
rows, err := db.Query("select * from users where name = ?", "linuxfish")
</code></p>

<p>与之比较的是还有一种写法，这种是臭名昭著的sql拼接，之前一直理解上面的那种写法也是sql拼接，看来是错怪它了：</p>

<p><code>go
// 这样写是有被sql注入的危险的
myName := getNameFromUser()
rows, err := db.Query("select * from users where name = " + myName)
</code></p>

<p>那么 Parameterized Queries 的好处是什么？</p>

<ul>
<li>安全

<ul>
<li>the best way to prevent SQL injection.</li>
</ul>
</li>
<li>性能高

<ul>
<li>数据库会缓存执行计划，但必须是一模一样的sql，差一点都不行，那么在实际应用中这个缓存的作用就大打折扣了，因为<code>select * from users where id = 2</code>和<code>select * from users where id = 3</code>在数据库看来也是不一样的，尽管它们本质上是一个sql。</li>
<li>用Parameterized Queries可以解决这个问题，因为变化的值变成参数了，对于数据库而言，请求一直是<code>select * from users where id = ?</code></li>
<li>但其实并没有那么完美，使用Parameterized Queries后，尽管sql不变了，但相对于真正执行的sql，它缺失了一部分信息，导致优化器无法作出最优的执行计划，因为参数的不同，最终的执行计划也可能是不一样的，因此，使用Parameterized Queries会性能高，是个伪命题</li>
<li>这又是个取舍的问题（tradeoff），从总体来看，使用Parameterized Queries的好处还是大于坏处，所以，尽量还是使用Parameterized Queries</li>
<li>参考：<a href="https://use-the-index-luke.com/sql/where-clause/bind-parameters">Parameterized Queries</a></li>
</ul>
</li>
</ul>


<h3>what sqlx brings us</h3>

<h4>StructScan</h4>

<p>这是下面说的 Get 和 Select 实现的基础，支持把select出来的字段一下scan进一个struct</p>

<p>The primary extension on sqlx.Rows is StructScan(), which automatically scans results into struct fields. Note that the fields must be exported (capitalized) in order for sqlx to be able to write into them, something true of all marshallers in Go. You can use the db struct tag to specify which column name maps to each struct field, or set a new default mapping with db.MapperFunc(). The default behavior is to use strings.Lower on the field name to match against the column names.</p>

<p>那么是根据什么规则scan的呢？如上面所说，优先会找字段有没有设置<code>db</code> tag，如果设置了就用它，如果没有设置，那么默认使用的是<code>strings.Lower(fieldName)</code>，当然这个转换机制是可以定制的，你可以传入自己的处理函数。对应的实现代码应该在这里：</p>

<p>```go
var NameMapper = strings.ToLower</p>

<p>// &hellip;</p>

<p>// mapper returns a valid mapper using the configured NameMapper func.
func mapper() *reflectx.Mapper {</p>

<pre><code>mprMu.Lock()
defer mprMu.Unlock()

if mpr == nil {
    mpr = reflectx.NewMapperFunc("db", NameMapper)
} else if origMapper != reflect.ValueOf(NameMapper) {
    // if NameMapper has changed, create a new mapper
    mpr = reflectx.NewMapperFunc("db", NameMapper)
    origMapper = reflect.ValueOf(NameMapper)
}
return mpr
</code></pre>

<p>}</p>

<p>// 定制自己的mapper
import &ldquo;github.com/jmoiron/sqlx/reflectx&rdquo;</p>

<p>// Create a new mapper which will use the struct field tag &ldquo;json&rdquo; instead of &ldquo;db&rdquo;
db.Mapper = reflectx.NewMapperFunc(&ldquo;json&rdquo;, strings.ToLower)
```</p>

<h4>Get and Select</h4>

<p>把 query 和 scan 结合到一步了！</p>

<p>```go
p := Place{}
pp := []Place{}</p>

<p>// this will pull the first place directly into p
err = db.Get(&amp;p, &ldquo;SELECT * FROM place LIMIT 1&rdquo;)</p>

<p>// this will pull places with telcode > 50 into the slice pp
err = db.Select(&amp;pp, &ldquo;SELECT * FROM place WHERE telcode > ?&rdquo;, 50)</p>

<p>// they work with regular types as well
var id int
err = db.Get(&amp;id, &ldquo;SELECT count(*) FROM place&rdquo;)</p>

<p>// fetch at most 10 place names
var names []string
err = db.Select(&amp;names, &ldquo;SELECT name FROM place LIMIT 10&rdquo;)
```
risks 潜在风险点</p>

<p>Select can save you a lot of typing, but beware! It&rsquo;s semantically different from Queryx, since <strong>it will load the entire result set into memory at once.</strong> If that set is not bounded by your query to some reasonable size, it might be best to use the classic Queryx/StructScan iteration instead. 作者建议如果返回的数据集大小不确定，还是使用经典的for Next Scan的模式</p>

<h5>Todo： 了解下 Get 和 Select 的原理</h5>

<h4>Transactions</h4>

<p>Exec and all other query verbs will ask the DB for a connection and then return it to the pool each time. There&rsquo;s no guarantee that you will receive the same connection that the BEGIN statement was executed on. To use transactions, you must therefore use <code>DB.Begin()</code> 必须先 Begin 一个transaction</p>

<p><code>go
tx, err := db.Begin()
err = tx.Exec(...)
err = tx.Commit()
</code></p>

<p>Since transactions are connection state, the Tx object must bind and control a single connection from the pool. A Tx will maintain that single connection for its entire life cycle, releasing it only when Commit() or Rollback() is called. You should take care to call at least one of these, or else the connection will be held until garbage collection. 只有当<code>Commit()</code>或<code>Rollback()</code>时数据库连接才被放回连接池，记得调这两个函数，否则会有连接不释放的问题</p>

<p>Because you only have one connection to use in a transaction, you can only execute one statement at a time; the cursor types Row and Rows must be Scanned or Closed, respectively, before executing another query. If you attempt to send the server data while it is sending you a result, it can potentially corrupt the connection. 事务中只有一个连接可以使用，因此查询（Query）必须被Scan完或者Close后，后续的查询才能继续执行。</p>

<h4>Named Queries</h4>

<p>Named queries are common to many other database packages. They allow you to use a bindvar syntax which refers to the names of struct fields or map keys to bind variables a query, rather than having to refer to everything positionally. 这个类似于 Python format中的这种写法：<code>print("网站名：{name}, 地址 {url}".format(name="菜鸟教程", url="www.runoob.com"))</code> 好处是不用在意参数的位置了。</p>

<p><code>``go
// named query with a struct
p := Place{Country: "South Africa"}
rows, err := db.NamedQuery(</code>SELECT * FROM place WHERE country=:country`, p)</p>

<p>// named query with a map
m := map[string]interface{}{&ldquo;city&rdquo;: &ldquo;Johannesburg&rdquo;}
result, err := db.NamedExec(<code>SELECT * FROM place WHERE city=:city</code>, m)
```
Named query support is implemented by parsing the query for the :param syntax and replacing it with the bindvar supported by the underlying database, then performing the mapping at execution, so it is usable on any database that sqlx supports. 实现原理</p>

<h4>Advanced Scanning</h4>

<h5>Scan Destination Safety</h5>

<p>扫描的destination变量里的字段必须是select的字段的超集，否则会报错，当然也可以忽略这个错误</p>

<p><code>``go
var p Person
// err here is not nil because there are no field destinations for columns in</code>place`
err = db.Get(&amp;p, &ldquo;SELECT * FROM person, place LIMIT 1;&rdquo;)</p>

<p>// this will NOT return an error, even though place columns have no destination
udb := db.Unsafe()
err = udb.Get(&amp;p, &ldquo;SELECT * FROM person, place LIMIT 1;&rdquo;)
```</p>

<h5>Alternate Scan Types</h5>

<p>In addition to using Scan and StructScan, an sqlx Row or Rows can be used to automatically return a slice or a map of results，还能scan成slice和map！！:</p>

<p>```go
rows, err := db.Queryx(&ldquo;SELECT * FROM place&rdquo;)
for rows.Next() {</p>

<pre><code>// cols is an []interface{} of all of the column results
cols, err := rows.SliceScan()
</code></pre>

<p>}</p>

<p>rows, err := db.Queryx(&ldquo;SELECT * FROM place&rdquo;)
for rows.Next() {</p>

<pre><code>results := make(map[string]interface{})
err = rows.MapScan(results)
</code></pre>

<p>}
```</p>

<h5>Custom Types / 自定义类型</h5>

<p>the examples above all used the built-in types to both scan and query with, but database/sql provides interfaces to allow you to use any custom types. database/sql包提供了接口让你来扩展你的自定义类型，让它们也可以被Scan和Query</p>

<p>参考：<a href="http://jmoiron.net/blog/built-in-interfaces">Built In Interfaces</a></p>

<h4>The Connection Pool</h4>

<p>database/sql 包内置连接池，而且提供了几个函数来定制连接池的行为：</p>

<ul>
<li>DB.SetMaxIdleConns(n int)

<ul>
<li> sets the maximum number of connections in the idle connection pool</li>
<li> The default max idle connections is currently 2. This may change in a future release. 默认2个</li>
</ul>
</li>
<li>DB.SetMaxOpenConns(n int)

<ul>
<li>sets the maximum number of open connections to the database.</li>
<li>默认无限制</li>
</ul>
</li>
<li>DB.SetConnMaxLifetime(d time.Duration)

<ul>
<li>sets the maximum amount of time a connection may be reused.</li>
</ul>
</li>
</ul>


<h3>参考</h3>

<ul>
<li><a href="http://jmoiron.github.io/sqlx/">Illustrated guide to SQLX</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Error Handling in Go]]></title>
    <link href="http://cs50Mu.github.io/blog/2019/05/09/error-handling-in-go/"/>
    <updated>2019-05-09T08:50:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2019/05/09/error-handling-in-go</id>
    <content type="html"><![CDATA[<p>From: <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">Don’t just check errors, handle them gracefully</a></p>

<h3>error变量</h3>

<p>```go
var ErrNotFound = errors.New(&ldquo;datastore:notfound&rdquo;)</p>

<p>err := Foo()
if err == ErrNotFound {</p>

<pre><code>// ...
}
</code></pre>

<p>```</p>

<p>优点：简单</p>

<p>缺点：不能带上下文，只有一个简单的固定字符描述；而且错误要耦合进调用方</p>

<h3>error类型</h3>

<p>好处是可以承载更多的上下文信息</p>

<p>缺点还是这个错误必须耦合进调用方</p>

<p>```go
type PathError struct {
Op string
Path string
Err error
}</p>

<p>func (e *PathError) Error() string {</p>

<pre><code>return ""
</code></pre>

<p>}</p>

<p>if err, ok := err.(PathError); ok {</p>

<p>}
```</p>

<h3>opaque error handling / 黑盒错误处理</h3>

<p>不对返回的error做任何假设，因此也不能干啥。。  直接返回error</p>

<p>```go
func foo() error {</p>

<pre><code>x, err := bar()
if err != nil {
    return err
}

// use x
</code></pre>

<p>```</p>

<h3>assert errors for behavior, not type / 根据行为来处理</h3>

<p>上面的方法太简单。。有时候确实是需要区分error种类，来按情况处理的。</p>

<p>```go
type temporary interface {</p>

<pre><code>    Temporary() bool
</code></pre>

<p>}</p>

<p>// IsTemporary returns true if err is temporary.
func IsTemporary(err error) bool {</p>

<pre><code>    te, ok := err.(temporary)
    return ok &amp;&amp; te.Temporary()
</code></pre>

<p>}
```</p>

<p>优点：调用方不用依赖定义error的包了</p>

<p>缺点：这种方法依赖 第三方包作者的配合，需要他先让他返回的error满足一定的interface（比如temporary)，包的使用者才能这么用呢</p>

<p>Don’t assert errors for type, assert for behaviour.</p>

<p>For package authors, if your package generates errors of a temporary nature, ensure you return error types that implement the respective interface methods. If you wrap error values on the way out, ensure that your wrappers respect the interface(s) that the underlying error value implemented.</p>

<p>For package users, if you need to inspect an error, use interfaces to assert the behaviour you expect, not the error’s type. Don’t ask package authors for public error types; ask that they make their types conform to common interfaces by supplying Timeout() or Temporary() methods as appropriate.</p>

<p>参考：</p>

<ul>
<li><a href="https://dave.cheney.net/2014/12/24/inspecting-errors">Inspecting errors</a></li>
</ul>


<h3>extra tip</h3>

<ul>
<li><p>annotating errors</p></li>
<li><p>only handle errors once</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
