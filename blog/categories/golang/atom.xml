<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Golang | The Hard Way Is Easier]]></title>
  <link href="http://cs50Mu.github.io/blog/categories/golang/atom.xml" rel="self"/>
  <link href="http://cs50Mu.github.io/"/>
  <updated>2019-05-19T22:49:00+08:00</updated>
  <id>http://cs50Mu.github.io/</id>
  <author>
    <name><![CDATA[linuxfish]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Golang 中的文字编码问题]]></title>
    <link href="http://cs50Mu.github.io/blog/2019/05/19/a-encoding-problem-in-golang/"/>
    <updated>2019-05-19T22:41:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2019/05/19/a-encoding-problem-in-golang</id>
    <content type="html"><![CDATA[<h3>过程描述</h3>

<p>记录一个文字编码的问题</p>

<p>在请求支付宝支付的接口时，发现返回的Response如果有中文的话，print出来后会有乱码。第一反应肯定是编码有问题，那就先转一下编码吧。</p>

<p>一开始的代码大概如下：</p>

<p>```go</p>

<pre><code>resp, err := client.Post(aliPayBillURL, "application/x-www-form-urlencoded", bytes.NewBufferString(output))
if err != nil {
    panic(err)
}
defer resp.Body.Close()
body, err := ioutil.ReadAll(resp.Body)
if err != nil {
    panic(err)
}
//...
err = json.Unmarshal(body, &amp;queryResp)
if err != nil {
    panic(err)
}
data := queryResp.Data
// data.SubMsg里含有中文，会乱码
if data.Code != "10000" {
    fmt.Printf("download failed: msg: %s, sub_code: %s, sub_msg: %s\n", data.Msg, data.SubCode, data.SubMsg)
    panic("download failed")
} 
</code></pre>

<p>```</p>

<p>改为了：</p>

<p>```go</p>

<pre><code>resp, err := client.Post(aliPayBillURL, "application/x-www-form-urlencoded", bytes.NewBufferString(output))
if err != nil {
    panic(err)
}
defer resp.Body.Close()
body, err := ioutil.ReadAll(resp.Body)
if err != nil {
    panic(err)
}
//...
err = json.Unmarshal(body, &amp;queryResp)
if err != nil {
    panic(err)
}
data := queryResp.Data
converted, err := gbkToUtf8([]byte(data.SubMsg))
if err != nil {
    panic(err)
}
if data.Code != "10000" {
    fmt.Printf("download failed: msg: %s, sub_code: %s, sub_msg: %s\n", data.Msg, data.SubCode, converted)
    panic("download failed")
}
</code></pre>

<p>```</p>

<p>结果是依旧乱码。。难道不是编码的问题？</p>

<p>改<code>%s</code>为<code>%x</code>看看具体字节：</p>

<p>```go</p>

<pre><code>if data.Code != "10000" {
    fmt.Printf("download failed: msg: %s, sub_code: %s, sub_msg: %x\n", data.Msg, data.SubCode, converted)
    panic("download failed")
}
</code></pre>

<p>```</p>

<p>然后看到了这个<code>efbfbdefbfbdd0a7efbfbdefbfbd 4170704944 efbfbdefbfbdefbfbd</code>，之所以分成了三段贴出来，是因为我发现中间那段对应了部分正常显示的字符“Appid”，然后尝试手动解码一下其它两段，不管是GBK还是utf8都没有找到对应的字符。</p>

<p>然后发现第一段和最后一段的模式有点类似啊，都是<code>efbfbd</code>啥的，有点奇怪。尝试直接搜索<code>efbfbd</code>，定位到一篇<a href="https://liudanking.com/golang/utf-8_replacement_character/">文章</a>，里面主要讲到两点：</p>

<ul>
<li>这个序列就是utf8编码的，但它比较特殊，它是专门用来替换那些在解码时不认识的码点的，显示出来就是「�」</li>
<li>某些语言，比如 Goang，会自动进行这个转换，不会报错</li>
</ul>


<p>借用一下原文的例子：</p>

<p><code>go
now := time.Now().Unix() // 一个无效的码点值
str := string(now) // golang是utf-8编码，会对无效码点进行替换
fmt.Printf("%X", []byte(str)) // EFBFBD，即字符「�」
</code></p>

<p>这一下坚定了认为是编码的问题，那就是转码出问题了，再一看，我是在json decode之后再转码的，json decode的时候可能已经把数据按utf8解码了，而数据如果不是utf8编码的话，那就都被替换成<code>efbfbd</code>了，改为在json decode之前就转码试试：</p>

<p>```go</p>

<pre><code>resp, err := client.Post(aliPayBillURL, "application/x-www-form-urlencoded", bytes.NewBufferString(output))
if err != nil {
    panic(err)
}
defer resp.Body.Close()
body, err := ioutil.ReadAll(resp.Body)
if err != nil {
    panic(err)
}
converted, err := gbkToUtf8([]byte(body))
if err != nil {
    panic(err)
}
fmt.Println(string(converted))
err = json.Unmarshal(converted, &amp;queryResp)
if err != nil {
    panic(err)
}
data := queryResp.Data
if data.Code != "10000" {
    fmt.Printf("download failed: msg: %s, sub_code: %s, sub_msg: %s\n", data.Msg, data.SubCode, data.SubMsg)
    panic("download failed")
}
</code></pre>

<p>```</p>

<p>这次没问题了。</p>

<h3>反思 &amp;&amp; 教训</h3>

<ul>
<li>获取到数据后不要做任何操作，先做转码</li>
<li>记住<code>efbfbd</code>，它是一个信号，说明源数据一定不是utf8编码的</li>
</ul>


<p>最后，记录一下 Golang 中如何从 GBK 转为 utf8</p>

<p>```go
import (
golang.org/x/text/encoding/simplifiedchinese
golang.org/x/text/transform
)</p>

<p>func gbkToUtf8(s []byte) ([]byte, error) {</p>

<pre><code>reader := transform.NewReader(bytes.NewReader(s), simplifiedchinese.GBK.NewDecoder())
d, err := ioutil.ReadAll(reader)
if err != nil {
    return nil, err
}
return d, nil
</code></pre>

<p>}
```</p>

<h3>参考</h3>

<ul>
<li><a href="https://liudanking.com/golang/utf-8_replacement_character/">你应该记住的一个UTF-8字符「EF BF BD」</a></li>
<li><a href="http://mengqi.info/html/2015/201507071345-using-golang-to-convert-text-between-gbk-and-utf-8.html">Golang 中的 UTF-8 与 GBK 编码转换</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[database with sqlx in Golang]]></title>
    <link href="http://cs50Mu.github.io/blog/2019/05/09/database-with-sqlx-in-golang/"/>
    <updated>2019-05-09T10:39:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2019/05/09/database-with-sqlx-in-golang</id>
    <content type="html"><![CDATA[<h2>database with sqlx in Golang</h2>

<h3>Parameterized Queries</h3>

<p>翻译为参数化查询？是个什么概念呢？</p>

<p>Bind parameters—also called dynamic parameters or bind variables—are an alternative way to pass data to the database. Instead of putting the values directly into the SQL statement, you just use a placeholder like ?, :name or @name and provide the actual values using a separate API call.</p>

<p>原来说的是这种形式：</p>

<p><code>go
rows, err := db.Query("select * from users where name = ?", "linuxfish")
</code></p>

<p>与之比较的是还有一种写法，这种是臭名昭著的sql拼接，之前一直理解上面的那种写法也是sql拼接，看来是错怪它了：</p>

<p><code>go
// 这样写是有被sql注入的危险的
myName := getNameFromUser()
rows, err := db.Query("select * from users where name = " + myName)
</code></p>

<p>那么 Parameterized Queries 的好处是什么？</p>

<ul>
<li>安全

<ul>
<li>the best way to prevent SQL injection.</li>
</ul>
</li>
<li>性能高

<ul>
<li>数据库会缓存执行计划，但必须是一模一样的sql，差一点都不行，那么在实际应用中这个缓存的作用就大打折扣了，因为<code>select * from users where id = 2</code>和<code>select * from users where id = 3</code>在数据库看来也是不一样的，尽管它们本质上是一个sql。</li>
<li>用Parameterized Queries可以解决这个问题，因为变化的值变成参数了，对于数据库而言，请求一直是<code>select * from users where id = ?</code></li>
<li>但其实并没有那么完美，使用Parameterized Queries后，尽管sql不变了，但相对于真正执行的sql，它缺失了一部分信息，导致优化器无法作出最优的执行计划，因为参数的不同，最终的执行计划也可能是不一样的，因此，使用Parameterized Queries会性能高，是个伪命题</li>
<li>这又是个取舍的问题（tradeoff），从总体来看，使用Parameterized Queries的好处还是大于坏处，所以，尽量还是使用Parameterized Queries</li>
<li>参考：<a href="https://use-the-index-luke.com/sql/where-clause/bind-parameters">Parameterized Queries</a></li>
</ul>
</li>
</ul>


<h3>what sqlx brings us</h3>

<h4>StructScan</h4>

<p>这是下面说的 Get 和 Select 实现的基础，支持把select出来的字段一下scan进一个struct</p>

<p>The primary extension on sqlx.Rows is StructScan(), which automatically scans results into struct fields. Note that the fields must be exported (capitalized) in order for sqlx to be able to write into them, something true of all marshallers in Go. You can use the db struct tag to specify which column name maps to each struct field, or set a new default mapping with db.MapperFunc(). The default behavior is to use strings.Lower on the field name to match against the column names.</p>

<p>那么是根据什么规则scan的呢？如上面所说，优先会找字段有没有设置<code>db</code> tag，如果设置了就用它，如果没有设置，那么默认使用的是<code>strings.Lower(fieldName)</code>，当然这个转换机制是可以定制的，你可以传入自己的处理函数。对应的实现代码应该在这里：</p>

<p>```go
var NameMapper = strings.ToLower</p>

<p>// &hellip;</p>

<p>// mapper returns a valid mapper using the configured NameMapper func.
func mapper() *reflectx.Mapper {</p>

<pre><code>mprMu.Lock()
defer mprMu.Unlock()

if mpr == nil {
    mpr = reflectx.NewMapperFunc("db", NameMapper)
} else if origMapper != reflect.ValueOf(NameMapper) {
    // if NameMapper has changed, create a new mapper
    mpr = reflectx.NewMapperFunc("db", NameMapper)
    origMapper = reflect.ValueOf(NameMapper)
}
return mpr
</code></pre>

<p>}</p>

<p>// 定制自己的mapper
import &ldquo;github.com/jmoiron/sqlx/reflectx&rdquo;</p>

<p>// Create a new mapper which will use the struct field tag &ldquo;json&rdquo; instead of &ldquo;db&rdquo;
db.Mapper = reflectx.NewMapperFunc(&ldquo;json&rdquo;, strings.ToLower)
```</p>

<h4>Get and Select</h4>

<p>把 query 和 scan 结合到一步了！</p>

<p>```go
p := Place{}
pp := []Place{}</p>

<p>// this will pull the first place directly into p
err = db.Get(&amp;p, &ldquo;SELECT * FROM place LIMIT 1&rdquo;)</p>

<p>// this will pull places with telcode > 50 into the slice pp
err = db.Select(&amp;pp, &ldquo;SELECT * FROM place WHERE telcode > ?&rdquo;, 50)</p>

<p>// they work with regular types as well
var id int
err = db.Get(&amp;id, &ldquo;SELECT count(*) FROM place&rdquo;)</p>

<p>// fetch at most 10 place names
var names []string
err = db.Select(&amp;names, &ldquo;SELECT name FROM place LIMIT 10&rdquo;)
```
risks 潜在风险点</p>

<p>Select can save you a lot of typing, but beware! It&rsquo;s semantically different from Queryx, since <strong>it will load the entire result set into memory at once.</strong> If that set is not bounded by your query to some reasonable size, it might be best to use the classic Queryx/StructScan iteration instead. 作者建议如果返回的数据集大小不确定，还是使用经典的for Next Scan的模式</p>

<h5>Todo： 了解下 Get 和 Select 的原理</h5>

<h4>Transactions</h4>

<p>Exec and all other query verbs will ask the DB for a connection and then return it to the pool each time. There&rsquo;s no guarantee that you will receive the same connection that the BEGIN statement was executed on. To use transactions, you must therefore use <code>DB.Begin()</code> 必须先 Begin 一个transaction</p>

<p><code>go
tx, err := db.Begin()
err = tx.Exec(...)
err = tx.Commit()
</code></p>

<p>Since transactions are connection state, the Tx object must bind and control a single connection from the pool. A Tx will maintain that single connection for its entire life cycle, releasing it only when Commit() or Rollback() is called. You should take care to call at least one of these, or else the connection will be held until garbage collection. 只有当<code>Commit()</code>或<code>Rollback()</code>时数据库连接才被放回连接池，记得调这两个函数，否则会有连接不释放的问题</p>

<p>Because you only have one connection to use in a transaction, you can only execute one statement at a time; the cursor types Row and Rows must be Scanned or Closed, respectively, before executing another query. If you attempt to send the server data while it is sending you a result, it can potentially corrupt the connection. 事务中只有一个连接可以使用，因此查询（Query）必须被Scan完或者Close后，后续的查询才能继续执行。</p>

<h4>Named Queries</h4>

<p>Named queries are common to many other database packages. They allow you to use a bindvar syntax which refers to the names of struct fields or map keys to bind variables a query, rather than having to refer to everything positionally. 这个类似于 Python format中的这种写法：<code>print("网站名：{name}, 地址 {url}".format(name="菜鸟教程", url="www.runoob.com"))</code> 好处是不用在意参数的位置了。</p>

<p><code>``go
// named query with a struct
p := Place{Country: "South Africa"}
rows, err := db.NamedQuery(</code>SELECT * FROM place WHERE country=:country`, p)</p>

<p>// named query with a map
m := map[string]interface{}{&ldquo;city&rdquo;: &ldquo;Johannesburg&rdquo;}
result, err := db.NamedExec(<code>SELECT * FROM place WHERE city=:city</code>, m)
```
Named query support is implemented by parsing the query for the :param syntax and replacing it with the bindvar supported by the underlying database, then performing the mapping at execution, so it is usable on any database that sqlx supports. 实现原理</p>

<h4>Advanced Scanning</h4>

<h5>Scan Destination Safety</h5>

<p>扫描的destination变量里的字段必须是select的字段的超集，否则会报错，当然也可以忽略这个错误</p>

<p><code>``go
var p Person
// err here is not nil because there are no field destinations for columns in</code>place`
err = db.Get(&amp;p, &ldquo;SELECT * FROM person, place LIMIT 1;&rdquo;)</p>

<p>// this will NOT return an error, even though place columns have no destination
udb := db.Unsafe()
err = udb.Get(&amp;p, &ldquo;SELECT * FROM person, place LIMIT 1;&rdquo;)
```</p>

<h5>Alternate Scan Types</h5>

<p>In addition to using Scan and StructScan, an sqlx Row or Rows can be used to automatically return a slice or a map of results，还能scan成slice和map！！:</p>

<p>```go
rows, err := db.Queryx(&ldquo;SELECT * FROM place&rdquo;)
for rows.Next() {</p>

<pre><code>// cols is an []interface{} of all of the column results
cols, err := rows.SliceScan()
</code></pre>

<p>}</p>

<p>rows, err := db.Queryx(&ldquo;SELECT * FROM place&rdquo;)
for rows.Next() {</p>

<pre><code>results := make(map[string]interface{})
err = rows.MapScan(results)
</code></pre>

<p>}
```</p>

<h5>Custom Types / 自定义类型</h5>

<p>the examples above all used the built-in types to both scan and query with, but database/sql provides interfaces to allow you to use any custom types. database/sql包提供了接口让你来扩展你的自定义类型，让它们也可以被Scan和Query</p>

<p>参考：<a href="http://jmoiron.net/blog/built-in-interfaces">Built In Interfaces</a></p>

<h4>The Connection Pool</h4>

<p>database/sql 包内置连接池，而且提供了几个函数来定制连接池的行为：</p>

<ul>
<li>DB.SetMaxIdleConns(n int)

<ul>
<li> sets the maximum number of connections in the idle connection pool</li>
<li> The default max idle connections is currently 2. This may change in a future release. 默认2个</li>
</ul>
</li>
<li>DB.SetMaxOpenConns(n int)

<ul>
<li>sets the maximum number of open connections to the database.</li>
<li>默认无限制</li>
</ul>
</li>
<li>DB.SetConnMaxLifetime(d time.Duration)

<ul>
<li>sets the maximum amount of time a connection may be reused.</li>
</ul>
</li>
</ul>


<h3>参考</h3>

<ul>
<li><a href="http://jmoiron.github.io/sqlx/">Illustrated guide to SQLX</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Error Handling in Go]]></title>
    <link href="http://cs50Mu.github.io/blog/2019/05/09/error-handling-in-go/"/>
    <updated>2019-05-09T08:50:00+08:00</updated>
    <id>http://cs50Mu.github.io/blog/2019/05/09/error-handling-in-go</id>
    <content type="html"><![CDATA[<p>From: <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">Don’t just check errors, handle them gracefully</a></p>

<h3>error变量</h3>

<p>```go
var ErrNotFound = errors.New(&ldquo;datastore:notfound&rdquo;)</p>

<p>err := Foo()
if err == ErrNotFound {</p>

<pre><code>// ...
}
</code></pre>

<p>```</p>

<p>优点：简单</p>

<p>缺点：不能带上下文，只有一个简单的固定字符描述；而且错误要耦合进调用方</p>

<h3>error类型</h3>

<p>好处是可以承载更多的上下文信息</p>

<p>缺点还是这个错误必须耦合进调用方</p>

<p>```go
type PathError struct {
Op string
Path string
Err error
}</p>

<p>func (e *PathError) Error() string {</p>

<pre><code>return ""
</code></pre>

<p>}</p>

<p>if err, ok := err.(PathError); ok {</p>

<p>}
```</p>

<h3>opaque error handling / 黑盒错误处理</h3>

<p>不对返回的error做任何假设，因此也不能干啥。。  直接返回error</p>

<p>```go
func foo() error {</p>

<pre><code>x, err := bar()
if err != nil {
    return err
}

// use x
</code></pre>

<p>```</p>

<h3>assert errors for behavior, not type / 根据行为来处理</h3>

<p>上面的方法太简单。。有时候确实是需要区分error种类，来按情况处理的。</p>

<p>```go
type temporary interface {</p>

<pre><code>    Temporary() bool
</code></pre>

<p>}</p>

<p>// IsTemporary returns true if err is temporary.
func IsTemporary(err error) bool {</p>

<pre><code>    te, ok := err.(temporary)
    return ok &amp;&amp; te.Temporary()
</code></pre>

<p>}
```</p>

<p>优点：调用方不用依赖定义error的包了</p>

<p>缺点：这种方法依赖 第三方包作者的配合，需要他先让他返回的error满足一定的interface（比如temporary)，包的使用者才能这么用呢</p>

<p>Don’t assert errors for type, assert for behaviour.</p>

<p>For package authors, if your package generates errors of a temporary nature, ensure you return error types that implement the respective interface methods. If you wrap error values on the way out, ensure that your wrappers respect the interface(s) that the underlying error value implemented.</p>

<p>For package users, if you need to inspect an error, use interfaces to assert the behaviour you expect, not the error’s type. Don’t ask package authors for public error types; ask that they make their types conform to common interfaces by supplying Timeout() or Temporary() methods as appropriate.</p>

<p>参考：</p>

<ul>
<li><a href="https://dave.cheney.net/2014/12/24/inspecting-errors">Inspecting errors</a></li>
</ul>


<h3>extra tip</h3>

<ul>
<li><p>annotating errors</p></li>
<li><p>only handle errors once</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
